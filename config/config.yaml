# =============================================================================
# AGENT ECOLOGY - CONFIGURATION
# =============================================================================
# All numbers that control the simulation. No magic numbers in code.
# Validated by Pydantic at startup (src/config_schema.py).
# =============================================================================

# -----------------------------------------------------------------------------
# RESOURCES - Map to real physical/financial scarcity
# -----------------------------------------------------------------------------
resources:
  stock:  # Finite pool, don't refresh
    llm_budget:
      total: 100.00             # $ for API calls (high limit)
      unit: dollars
      distribution: equal
    disk:
      total: 500000             # bytes total (100KB per agent with 5 agents)
      unit: bytes
      distribution: equal
  # Note: Flow resources (per_tick) removed in Plan #102
  # Use rate_limiting section for time-based resource limits

# -----------------------------------------------------------------------------
# SCRIP - Economic currency (not a resource)
# -----------------------------------------------------------------------------
scrip:
  starting_amount: 100

# -----------------------------------------------------------------------------
# DELEGATION - Charge delegation settings
# -----------------------------------------------------------------------------
delegation:
  max_history: 1000            # Max charge history entries per (payer, charger) pair

# -----------------------------------------------------------------------------
# COSTS - DEPRECATED (Plan #153)
# -----------------------------------------------------------------------------
# These abstract cost rates are deprecated. The system now uses
# actual dollar costs from the models.pricing section below.
# Kept for backward compatibility - will be ignored.
costs:
  per_1k_input_tokens: 1    # DEPRECATED - use models.pricing
  per_1k_output_tokens: 3   # DEPRECATED - use models.pricing

# -----------------------------------------------------------------------------
# MODEL PRICING - Per-model costs for LLM calls (Plan #153)
# -----------------------------------------------------------------------------
# Real dollar costs per model. Used for:
# 1. Pre-flight budget checks (can agent afford this call?)
# 2. Post-call deductions (actual cost from budget)
# 3. Dashboard display (estimated tokens remaining)
#
# If a model isn't listed here, LiteLLM's pricing is used as fallback.
# Prices are in dollars per 1 million tokens.
models:
  pricing:
    # Google - very cheap
    gemini/gemini-2.0-flash:
      input_per_1m: 0.075     # $0.075 per 1M input tokens
      output_per_1m: 0.30     # $0.30 per 1M output tokens
    gemini/gemini-1.5-flash:
      input_per_1m: 0.075
      output_per_1m: 0.30
    gemini/gemini-1.5-pro:
      input_per_1m: 1.25
      output_per_1m: 5.00
    # Anthropic - moderate
    anthropic/claude-3-5-sonnet-20241022:
      input_per_1m: 3.0
      output_per_1m: 15.0
    anthropic/claude-3-haiku-20240307:
      input_per_1m: 0.25
      output_per_1m: 1.25
    # OpenAI - expensive
    openai/gpt-4o:
      input_per_1m: 2.50
      output_per_1m: 10.0
    openai/gpt-4o-mini:
      input_per_1m: 0.15
      output_per_1m: 0.60
    openai/gpt-4-turbo:
      input_per_1m: 10.0
      output_per_1m: 30.0
  # Default pricing for unknown models (conservative estimate)
  default_pricing:
    input_per_1m: 3.0       # Assume Sonnet-level pricing
    output_per_1m: 15.0

# -----------------------------------------------------------------------------
# GENESIS ARTIFACTS - System services (fully configurable)
# -----------------------------------------------------------------------------
# NOTE: All method "cost" values are COMPUTE costs, not scrip.
# Scrip only flows via agent-to-agent trades and mint auction.
# -----------------------------------------------------------------------------
genesis:
  # Which artifacts to create
  artifacts:
    ledger:
      enabled: true
    mint:
      enabled: false
    rights_registry:
      enabled: true
    event_log:
      enabled: true
    escrow:
      enabled: true
    # store removed - use query_kernel action instead (Plan #190)
    debt_contract:
      enabled: true
    voting:
      enabled: true
    model_registry:
      enabled: true

  # Genesis Ledger - balance queries and transfers
  ledger:
    id: "genesis_ledger"
    description: "System ledger - check balances (flow/scrip) and transfer scrip"
    methods:
      balance:
        cost: 0                 # free - reading balance is free
        description: "Get flow and scrip balance for an agent. Args: [agent_id]"
      all_balances:
        cost: 0                 # free - public information
        description: "Get all agent balances (flow and scrip). Args: []"
      transfer:
        cost: 1                 # cost 1
        description: "Transfer SCRIP to another agent. Args: [from_id, to_id, amount]"
      spawn_principal:
        cost: 1                 # cost 1
        description: "Spawn a new principal with 0 scrip and no resources. Args: []"
      transfer_ownership:
        cost: 1                 # cost 1
        description: "Transfer artifact ownership to another principal. Args: [artifact_id, to_id]"

  # Genesis Mint - auction-based scoring and minting
  mint:
    id: "genesis_mint"
    description: "Auction-based mint - bid to submit artifacts for LLM scoring"
    mint_ratio: 10              # score / 10 = scrip minted

    # Auction configuration (all times in seconds)
    auction:
      period_seconds: 60.0      # Seconds between auction starts
      bidding_window_seconds: 30.0  # Duration of bidding phase (seconds)
      first_auction_delay_seconds: 30.0  # Delay before first auction starts
      slots_per_auction: 1      # Winners per auction
      minimum_bid: 1            # Floor bid amount
      tie_breaking: "random"    # "random" or "first_bid"
      show_bid_count: true      # Show number of bids during window
      allow_bid_updates: true   # Can agents update their bid?
      refund_on_scoring_failure: true  # Refund if LLM scoring fails

    methods:
      status:
        cost: 0                 # free
        description: "Check auction status (phase, event_number, bid count). Args: []"
      bid:
        cost: 0                 # free - bidding is free
        description: "Submit sealed bid during bidding window. Args: [artifact_id, amount]"
      check:
        cost: 0                 # free
        description: "Check your bid/submission status. Args: [artifact_id]"

  # Genesis Rights Registry - quota management
  rights_registry:
    id: "genesis_rights_registry"
    description: "Rights registry - manage resource quotas (llm_budget, disk)"
    methods:
      check_quota:
        cost: 0                 # free
        description: "Check quotas for an agent. Args: [agent_id]"
      all_quotas:
        cost: 0                 # free - public information
        description: "Get all agent quotas. Args: []"
      transfer_quota:
        cost: 1                 # cost 1
        description: "Transfer quota to another agent. Args: [from_id, to_id, 'llm_tokens'|'disk', amount]"

  # Genesis Event Log - passive observability
  event_log:
    id: "genesis_event_log"
    description: "World event log - passive observability. Reading is free but costs input tokens."
    max_per_read: 100           # Cap events returned per read
    buffer_size: 1000           # Internal buffer size
    methods:
      read:
        cost: 0                 # free - but consumes input tokens
        description: "Read recent events. Args: [offset, limit] - both optional. Default: last 50 events."

  # Genesis Escrow - trustless artifact trading
  escrow:
    id: "genesis_escrow"
    description: "Trustless escrow for artifact trading. Seller deposits, buyer purchases, escrow handles exchange."
    methods:
      deposit:
        cost: 1                 # cost 1
        description: "Deposit artifact for sale. First transfer ownership to escrow. Args: [artifact_id, price] or [artifact_id, price, buyer_id]"
      purchase:
        cost: 0                 # free - buyer already pays the price
        description: "Purchase a listed artifact. Pays price to seller, transfers ownership to buyer. Args: [artifact_id]"
      cancel:
        cost: 0                 # free - encourage cleanup
        description: "Cancel listing and return artifact to seller. Only seller can cancel. Args: [artifact_id]"
      check:
        cost: 0                 # free
        description: "Check status of an escrow listing. Args: [artifact_id]"
      list_active:
        cost: 0                 # free - encourage discovery
        description: "List all active escrow listings. Args: []"

  # Genesis Debt Contract - non-privileged lending example
  debt_contract:
    id: "genesis_debt_contract"
    description: "Non-privileged debt contract example. Issue, accept, repay, collect debts. No magic enforcement - bad debtors get bad reputation."
    methods:
      issue:
        cost: 1                 # cost 1
        description: "Issue a debt. Invoker becomes debtor. Args: [creditor_id, principal, interest_rate, due_event]"
      accept:
        cost: 0                 # free - creditor accepts
        description: "Accept a pending debt (creditor must call). Args: [debt_id]"
      repay:
        cost: 0                 # free - debtor pays
        description: "Repay debt (debtor pays creditor). Args: [debt_id, amount]"
      collect:
        cost: 0                 # free - attempt collection
        description: "Collect overdue debt (creditor only, after due_event). Args: [debt_id]"
      transfer_creditor:
        cost: 1                 # cost 1
        description: "Transfer creditor rights to another principal (sell the debt). Args: [debt_id, new_creditor_id]"
      check:
        cost: 0                 # free
        description: "Check status of a debt. Args: [debt_id]"
      list_debts:
        cost: 0                 # free
        description: "List debts for a principal. Args: [principal_id]"
      list_all:
        cost: 0                 # free
        description: "List all debts. Args: []"

  # Genesis Voting - multi-party consensus (Plan #183)
  voting:
    id: "genesis_voting"
    description: "Multi-party voting for consensus. Create proposals, vote, track results."
    methods:
      create_proposal:
        cost: 1                 # cost 1 - costs to create a proposal
        description: "Create a proposal. Args: [{title, description?, options?, quorum?, threshold?, deadline_seconds?}]"
      vote:
        cost: 0                 # free - voting is free
        description: "Vote on a proposal. Args: [{proposal_id, choice}]"
      get_result:
        cost: 0                 # free - reading results is free
        description: "Get proposal results. Args: [proposal_id]"
      list_proposals:
        cost: 0                 # free - listing is free
        description: "List proposals with optional filter. Args: [{status?, creator?, limit?}]"

  # Note: genesis_store removed in Plan #190. Use query_kernel action instead.
  # query_kernel is free and provides direct kernel state access for discovery.

  # MCP servers for external tool access
  mcp:
    fetch:
      enabled: true                 # HTTP fetch capability
      command: "npx"
      args: ["@anthropic/mcp-server-fetch"]
    web_search:
      enabled: false                # Disabled - requires BRAVE_API_KEY env var
      command: "npx"
      args: ["@anthropic/mcp-server-brave-search"]
    filesystem:
      enabled: true                 # Sandboxed file I/O
      command: "npx"
      args: ["@anthropic/mcp-server-filesystem", "/tmp/agent_sandbox"]

# -----------------------------------------------------------------------------
# RATE LIMITING - Rolling window rate limiting (time-based, not tick-based)
# -----------------------------------------------------------------------------
rate_limiting:
  enabled: true                   # RateTracker-based rolling window rate limiting
  window_seconds: 60.0            # 60 second rolling window
  resources:
    llm_tokens:
      max_per_window: 1000000000  # 1 billion - effectively unlimited
    llm_calls:
      max_per_window: 1000000000  # 1 billion - effectively unlimited
    disk_writes:
      max_per_window: 1000000     # 1M disk writes per 60 seconds
    bandwidth_bytes:
      max_per_window: 1073741824  # 1GB per 60 seconds
    cpu_seconds:
      max_per_window: 5.0         # Max 5 CPU-seconds per 60 seconds (renewable)
    memory_bytes:
      max_per_window: 104857600   # 100MB per 60 seconds (100 * 1024 * 1024)

# -----------------------------------------------------------------------------
# EXECUTION - Agent execution model settings (autonomous mode only, Plan #102)
# -----------------------------------------------------------------------------
execution:
  use_worker_pool: false          # Use worker pool for process-isolated turns (Plan #53)
  worker_pool:
    num_workers: 4                # Number of worker threads
    state_db_path: "agent_state.db"  # Path to SQLite state database
  agent_loop:
    min_loop_delay: 0.1           # Minimum seconds between actions
    max_loop_delay: 10.0          # Maximum backoff delay on errors
    resource_check_interval: 1.0  # Seconds between resource checks when paused
    max_consecutive_errors: 5     # Errors before forced pause
    resources_to_check:           # Resource types to check before each iteration
      - llm_tokens
      - llm_calls
      - disk_writes
      - bandwidth_bytes
    resource_exhaustion_policy: "skip"  # Policy when resources exhausted: "skip" or "block"
                                        # - "skip": Skip action, try again next iteration (safer)
                                        # - "block": Block until capacity available

# -----------------------------------------------------------------------------
# TIMEOUTS - Consolidated timeout values for all components
# -----------------------------------------------------------------------------
timeouts:
  agent_loop_stop: 5.0           # AgentLoop stop timeout (seconds)
  loop_manager_stop: 10.0        # AgentLoopManager stop_all timeout (seconds)
  simulation_shutdown: 5.0       # SimulationRunner shutdown timeout (seconds)
  mcp_server: 5.0                # MCP server operations timeout (seconds)
  state_store_lock: 30.0         # SQLite lock timeout (seconds)
  state_store_retry_max: 10      # Max retry attempts for SQLite lock errors
  state_store_retry_base: 0.05   # Base backoff delay seconds (faster retries)
  state_store_retry_max_delay: 2.0  # Max backoff delay seconds
  dashboard_server: 30.0         # Dashboard server operations timeout (seconds)

# -----------------------------------------------------------------------------
# EXECUTOR
# -----------------------------------------------------------------------------
executor:
  timeout_seconds: 5
  max_invoke_depth: 5            # Maximum artifact invocation nesting depth
  max_contract_depth: 10         # Maximum contract permission check depth (Plan #100)
  contract_timeout: 5            # Default contract permission check timeout (Plan #100)
  contract_llm_timeout: 30       # Timeout for contracts with call_llm capability (Plan #100)
  interface_validation: strict   # Plan #86: 'none', 'warn', or 'strict' - strict gives agents helpful error messages
  require_interface_for_executables: true  # Plan #114: Require interface schema when creating executables
  # NOTE: These modules are PRE-LOADED into the execution namespace.
  # This is NOT a security whitelist - agents can import any stdlib module.
  # Security boundary is the container, not code-level sandboxing.
  # See docs/SECURITY.md for rationale.
  preloaded_imports:
    - math
    - json
    - random
    - datetime

# -----------------------------------------------------------------------------
# CONTRACTS - Contract system configuration (Plan #100, ADR-0017, ADR-0019)
# -----------------------------------------------------------------------------
contracts:
  default_when_null: creator_only                # Null contract: only creator can access (ADR-0019)
  default_on_missing: kernel_contract_freeware  # Dangling contract: fallback to freeware (ADR-0017)

# -----------------------------------------------------------------------------
# VALIDATION - Input validation limits to prevent DoS
# -----------------------------------------------------------------------------
validation:
  max_artifact_id_length: 128   # Max chars for artifact IDs
  max_method_name_length: 64    # Max chars for method names

# -----------------------------------------------------------------------------
# MINT SCORER
# -----------------------------------------------------------------------------
mint_scorer:
  model: "gemini/gemini-2.0-flash"
  timeout: 30
  max_content_length: 200000
  score_bounds:
    min: 0
    max: 100
  thread_pool_workers: 1

# -----------------------------------------------------------------------------
# LLM
# -----------------------------------------------------------------------------
llm:
  default_model: "gemini/gemini-2.0-flash"
  timeout: 60
  rate_limit_delay: 5  # Reduced from 15s for faster iteration
  # Models that agents are allowed to use (for future self-modification)
  allowed_models:
    - "gemini/gemini-2.0-flash"
  # Extended thinking for Claude models (Plan #187)
  # Values: "none" (disabled), "low", "medium", "high"
  # WARNING: Higher values cost 5-10x more
  reasoning_effort: null  # Disabled by default

# -----------------------------------------------------------------------------
# LOGGING
# -----------------------------------------------------------------------------
logging:
  output_file: "run.jsonl"
  logs_dir: "logs"              # Per-run logs directory (events.jsonl per run)
  log_dir: "llm_logs"
  default_recent: 50
  truncation:                   # Log message truncation limits
    content: 100                # Artifact content in logs
    code: 100                   # Code snippets in logs
    errors: 100                 # Error messages
    detailed: 500               # Detailed logs
    result_data: 1000           # ActionResult.data in logs (Plan #80)

# -----------------------------------------------------------------------------
# MONITORING - Ecosystem health settings
# -----------------------------------------------------------------------------
monitoring:
  audit_thresholds:
    gini:
      warning: 0.7
      critical: 0.9
    frozen_ratio:
      warning: 0.2
      critical: 0.5
    active_ratio:
      warning: 0.3
      critical: 0.1
    burn_rate:
      warning: 0.1
      critical: 0.25
    scrip_velocity_low:
      warning: 0.001
  health_scoring:
    warning_penalty: 0.1
    critical_penalty: 0.2
    trend_threshold: 0.1
    trend_history_events: 10
  active_agent_threshold_seconds: 60.0

# -----------------------------------------------------------------------------
# AGENT PROMPTS - What agents see in their context
# -----------------------------------------------------------------------------
agent:
  prompt:
    recent_events_count: 5        # Last N events shown in prompt
    memory_limit: 5               # Max relevant memories to include
    # Startup hint - shown on first iteration to help new agents
    startup_hint_enabled: true
    startup_hint: |
      TIP: New to this world? Read handbook_actions for available actions,
      or handbook_trading for how to buy/sell through escrow.

  # RAG (Retrieval-Augmented Generation) defaults
  # Per-agent overrides in src/agents/<name>/agent.yaml
  rag:
    enabled: true                 # Set false to disable RAG entirely
    limit: 7                      # Increased for richer context
    # Query template - variables: {event_number}, {agent_id}, {balance}, {my_artifacts}, {other_agents}, {last_action}
    query_template: |
      I am {agent_id} at event {event_number} with {balance} scrip.
      My artifacts: {my_artifacts}. Last action: {last_action}

      LEARNING QUERY:
      - What strategies have worked for me before?
      - What mistakes have I made that I should avoid?
      - What patterns led to success vs failure?
      - What should I do differently this time?

  # Error messages - configurable with handbook references
  # Use {placeholders} for dynamic values: {artifact_id}, {method}, {methods}, {escrow_id}
  errors:
    access_denied_read: "Access denied: you are not allowed to read {artifact_id}. See handbook_actions for permissions."
    access_denied_write: "Access denied: you are not allowed to write to {artifact_id}. See handbook_actions for permissions."
    access_denied_invoke: "Access denied: you are not allowed to invoke {artifact_id}. See handbook_actions for permissions."
    method_not_found: "Method '{method}' not found on {artifact_id}. Available: {methods}. TIP: Call invoke_artifact('{artifact_id}', 'describe', []) to see method details."
    escrow_not_owner: "Escrow does not own {artifact_id}. See handbook_trading for the 2-step process: 1) edit_artifact to set owner to escrow, 2) deposit."

  # Working Memory (Plan #59) - Structured context for complex goal pursuit
  # Agents can store current_goal, progress, and lessons in their artifact content
  working_memory:
    enabled: true                 # Master switch - enables strategic learning
    auto_inject: true             # Inject into prompt automatically when enabled
    max_size_bytes: 4000          # Increased for richer learning context
    include_in_rag: true          # Include lessons in semantic search
    structured_format: true       # Enforce YAML schema vs freeform
    warn_on_missing: true         # Log warning if agent has no working memory

  # Failure tracking (Plan #88) - Recent failures shown in prompt for learning
  failure_history_max: 5          # Max recent failures to track per agent

  # Plan #188/#213: Deliberative planning pattern
  planning:
    enabled: true                 # Enable plan-before-act for better reasoning
    max_steps: 5                  # Max steps in a plan
    replan_on_failure: true       # Generate new plan if step fails

  # Action history (Plan #156) - Recent actions shown in prompt for loop detection
  action_history_max: 15          # Max recent actions to track per agent

  # Subscribed artifacts (Plan #191) - Auto-injected into agent prompts
  subscribed_artifacts:
    max_count: 5                  # Max artifacts an agent can subscribe to
    max_size_bytes: 2000          # Max content size per subscribed artifact (truncated)

  # Plan #132: Removed cognitive_schema - single standardized response format with 'reasoning' field

# -----------------------------------------------------------------------------
# WORLD
# -----------------------------------------------------------------------------
# Note: max_ticks removed in Plan #102. Use duration-based execution:
# - budget.max_api_cost for cost-based termination
# - rate_limiting for resource limits
# - --duration flag for time-based runs
world: {}

# -----------------------------------------------------------------------------
# PROMPT INJECTION (Plan #197)
# Mandatory content injection into agent prompts for alignment research
# -----------------------------------------------------------------------------
prompt_injection:
  enabled: false                  # Disabled by default
  scope: "all"                    # "none" | "genesis" | "all"
  mandatory_prefix: ""            # Content injected BEFORE system prompt
  mandatory_suffix: ""            # Content injected AFTER system prompt

# -----------------------------------------------------------------------------
# CONTEXT BUDGET (Plan #195)
# Token budget management for agent prompts
# -----------------------------------------------------------------------------
context_budget:
  enabled: false                  # Disabled by default (no truncation without opt-in)
  total_tokens: 4000              # Total tokens available for prompt
  output_reserve: 1000            # Tokens reserved for model output
  show_budget_usage: false        # Show budget usage section in prompt
  overflow_policy: "truncate"     # Policy: "truncate" or "drop" low priority
  # Per-section budgets with defaults
  sections:
    system_prompt:
      max_tokens: 800
      priority: "required"
      truncation_strategy: "end"
    working_memory:
      max_tokens: 600
      priority: "high"
      truncation_strategy: "end"
    rag_memories:
      max_tokens: 400
      priority: "medium"
      truncation_strategy: "end"
    action_history:
      max_tokens: 300
      priority: "medium"
      truncation_strategy: "start"   # Truncate oldest (start of list)
    failure_history:
      max_tokens: 200
      priority: "medium"
      truncation_strategy: "start"
    recent_events:
      max_tokens: 300
      priority: "low"
      truncation_strategy: "start"
    subscribed_artifacts:
      max_tokens: 400
      priority: "medium"
      truncation_strategy: "end"
    world_state:
      max_tokens: 500
      priority: "required"
      truncation_strategy: "end"

# -----------------------------------------------------------------------------
# BUDGET - Global API limit and runtime backstops
# -----------------------------------------------------------------------------
budget:
  max_api_cost: 2.00            # $ (0 = unlimited). $2 for longer v2 experiment runs.
  max_runtime_seconds: 3600     # Hard timeout in seconds (0 = unlimited). Default 1 hour.
  checkpoint_file: "checkpoint.json"
  checkpoint_interval: 10       # Save checkpoint every N events (0 = disable)
  checkpoint_on_end: true       # Save checkpoint when simulation ends normally

# -----------------------------------------------------------------------------
# LEARNING - Cross-run learning configuration (Plan #186)
# -----------------------------------------------------------------------------
learning:
  cross_run:
    enabled: false                  # Disabled by default
    prior_checkpoint: null          # Path to checkpoint file (null = auto-discover)
    auto_discover: true             # Auto-find latest checkpoint in logs/
    load_working_memory: true       # Load working_memory from prior run

# (Memory tiering moved to memory: section above)

# -----------------------------------------------------------------------------
# LIBRARIES - Package installation for agents
# -----------------------------------------------------------------------------
libraries:
  # Genesis libraries: Pre-installed in Docker image, don't count against quota
  # These are cold-start conveniences, like genesis artifacts
  genesis:
    # HTTP
    - requests
    - aiohttp
    - urllib3
    # Data
    - numpy
    - pandas
    - python-dateutil
    # Scientific
    - scipy
    - matplotlib
    - scikit-learn       # ML: vectorization (TF-IDF), clustering, classification
    - networkx           # Graph analysis: structure, relationships, networks
    # Text processing
    - beautifulsoup4     # HTML/XML parsing
    - lxml               # Fast XML/HTML parser (bs4 backend)
    - regex              # Enhanced regex beyond stdlib re
    - tiktoken           # Token counting for LLM context management
    # Crypto
    - cryptography
    # Already in requirements.txt (core deps)
    - pyyaml
    - pydantic
    - jinja2

  # Blocked packages: Security risks (sandbox escape potential)
  blocked:
    - docker            # Docker daemon access
    - debugpy           # Debugger attachment
    - pyautogui         # Desktop automation
    - keyboard          # Keyboard input capture
    - pynput            # Input device control

# -----------------------------------------------------------------------------
# DASHBOARD - HTML visibility interface
# -----------------------------------------------------------------------------
dashboard:
  enabled: true
  host: "0.0.0.0"
  port: 9000
  static_dir: "src/dashboard/static"
  jsonl_file: "logs/latest/events.jsonl"
  websocket_path: "/ws"
  cors_origins: ["*"]
  max_events_cache: 10000
  debounce_delay_ms: 100        # File watcher debounce delay
  poll_interval: 0.5            # Polling interval seconds
  use_polling: false            # Use polling instead of watchdog (enable for WSL compatibility)

# -----------------------------------------------------------------------------
# ID GENERATION
# -----------------------------------------------------------------------------
id_generation:
  uuid_hex_length: 8            # Characters from UUID hex for IDs

# -----------------------------------------------------------------------------
# ALPHA PRIME - V4 Artifact-Based Agent
# -----------------------------------------------------------------------------
alpha_prime:
  enabled: true                           # Enabled for v2 experiment
  starting_scrip: 100                     # Initial scrip balance
  starting_llm_budget: 2.0                # $2 LLM budget for longer runs
  model: "gemini/gemini-2.0-flash"        # Model for Alpha Prime's cognition

# -----------------------------------------------------------------------------
# MINT TASKS - Task-Based Minting (Plan #269)
# -----------------------------------------------------------------------------
mint_tasks:
  enabled: false                          # Disabled â€” scrip is zero-sum
  seed_tasks:
    - task_id: "add_numbers"
      description: "Create an artifact that adds two numbers. Your run(a, b) function should return a + b."
      reward: 30
      public_tests:
        - description: "2 + 3 = 5"
          args: [2, 3]
          expected: 5
        - description: "0 + 0 = 0"
          args: [0, 0]
          expected: 0
      hidden_tests:
        - description: "Negative numbers"
          args: [-5, 3]
          expected: -2
        - description: "Large numbers"
          args: [999, 1]
          expected: 1000

    - task_id: "multiply_numbers"
      description: "Create an artifact that multiplies two numbers. Your run(a, b) function should return a * b."
      reward: 30
      public_tests:
        - description: "3 * 4 = 12"
          args: [3, 4]
          expected: 12
        - description: "0 * 5 = 0"
          args: [0, 5]
          expected: 0
      hidden_tests:
        - description: "Negative product"
          args: [-2, 3]
          expected: -6

    - task_id: "string_length"
      description: "Create an artifact that returns the length of a string. Your run(s) function should return len(s)."
      reward: 25
      public_tests:
        - description: "hello has 5 chars"
          args: ["hello"]
          expected: 5
        - description: "empty string"
          args: [""]
          expected: 0
      hidden_tests:
        - description: "With spaces"
          args: ["hello world"]
          expected: 11

    # --- Tier 2: Text Analysis (40 scrip) ---

    - task_id: "word_count"
      description: "Create an artifact that counts words in text. Your run(text) function should split on whitespace and return the word count as an integer."
      reward: 40
      public_tests:
        - description: "Simple sentence"
          args: ["hello world"]
          expected: 2
        - description: "Empty string"
          args: [""]
          expected: 0
      hidden_tests:
        - description: "Multiple spaces"
          args: ["  hello   world  "]
          expected: 2
        - description: "Single word"
          args: ["hello"]
          expected: 1

    - task_id: "word_frequency"
      description: "Create an artifact that counts word frequencies. Your run(text) function should return a dict mapping each lowercase word to its count. Split on whitespace, strip punctuation."
      reward: 40
      public_tests:
        - description: "Simple repetition"
          args: ["hello world hello"]
          expected: {"hello": 2, "world": 1}
        - description: "Single word"
          args: ["test"]
          expected: {"test": 1}
      hidden_tests:
        - description: "Case insensitive"
          args: ["Hello hello HELLO"]
          expected: {"hello": 3}
        - description: "With punctuation"
          args: ["hello, world! hello."]
          expected: {"hello": 2, "world": 1}

    - task_id: "sentence_count"
      description: "Create an artifact that counts sentences. Your run(text) function should count sentences (delimited by . ? or !) and return an integer."
      reward: 40
      public_tests:
        - description: "Two sentences"
          args: ["Hello world. How are you?"]
          expected: 2
        - description: "One sentence"
          args: ["Hello world."]
          expected: 1
      hidden_tests:
        - description: "Three types"
          args: ["Statement. Question? Exclamation!"]
          expected: 3
        - description: "Empty"
          args: [""]
          expected: 0

    # --- Tier 3: Discourse-Relevant (50 scrip) ---

    - task_id: "avg_sentence_length"
      description: "Create an artifact that computes average sentence length. Your run(text) function should split text into sentences (by . ? !), count words per sentence, and return the average as a float rounded to 1 decimal."
      reward: 50
      public_tests:
        - description: "Two equal sentences"
          args: ["I am here. You are there."]
          expected: 3.0
        - description: "Unequal sentences"
          args: ["Hi. How are you today?"]
          expected: 2.5
      hidden_tests:
        - description: "Single sentence"
          args: ["The quick brown fox jumps."]
          expected: 5.0
        - description: "Complex"
          args: ["Short. This is a longer sentence with many words."]
          expected: 4.5

    - task_id: "question_ratio"
      description: "Create an artifact that measures question density. Your run(text) function should return the ratio of questions to total sentences as a float rounded to 2 decimals. A question is a sentence ending with ?."
      reward: 50
      public_tests:
        - description: "Half questions"
          args: ["Statement. Question?"]
          expected: 0.50
        - description: "All questions"
          args: ["Really? Seriously?"]
          expected: 1.00
      hidden_tests:
        - description: "No questions"
          args: ["Hello. World."]
          expected: 0.00
        - description: "One of three"
          args: ["Hello. World? Goodbye."]
          expected: 0.33

    - task_id: "transition_word_count"
      description: "Create an artifact that counts discourse transition words. Your run(text) function should count occurrences of these words (case-insensitive): however, therefore, because, although, furthermore, moreover, nevertheless, consequently, meanwhile, thus. Return an integer."
      reward: 50
      public_tests:
        - description: "Two transitions"
          args: ["However, this is true. Therefore, we proceed."]
          expected: 2
        - description: "No transitions"
          args: ["Hello world."]
          expected: 0
      hidden_tests:
        - description: "Case insensitive"
          args: ["HOWEVER the plan failed. Because we tried."]
          expected: 2
        - description: "Multiple same word"
          args: ["Because this. Because that. Because reasons."]
          expected: 3

    # --- Tier 4: Complex Analysis (75 scrip) ---

    - task_id: "readability_score"
      description: "Create an artifact that computes Flesch Reading Ease. Your run(text) function should compute: 206.835 - 1.015*(total_words/total_sentences) - 84.6*(total_syllables/total_words). Estimate syllables by counting vowel groups (a,e,i,o,u) in each word (minimum 1 per word). Return a float rounded to 1 decimal."
      reward: 75
      public_tests:
        - description: "Simple text"
          args: ["The cat sat on the mat."]
          expected: 116.1
        - description: "Harder text"
          args: ["The extraordinary phenomenon demonstrates considerable complexity."]
          expected: -27.4
      hidden_tests:
        - description: "Two sentences"
          args: ["Short words here. Big complicated terminology utilized."]
          expected: 56.5

    - task_id: "extract_claims"
      description: "Create an artifact that extracts claim-indicator sentences. Your run(text) function should return a list of sentences that contain claim indicators: 'I believe', 'it follows', 'therefore', 'evidence shows', 'clearly', 'we must', 'the fact is', 'in conclusion'. Case-insensitive matching. Return list of matching sentence strings."
      reward: 75
      public_tests:
        - description: "One claim"
          args: ["The sky is blue. I believe this matters. The end."]
          expected: ["I believe this matters."]
        - description: "No claims"
          args: ["Hello world. Goodbye."]
          expected: []
      hidden_tests:
        - description: "Multiple claims"
          args: ["Clearly this is wrong. The weather is nice. Therefore we must act."]
          expected: ["Clearly this is wrong.", "Therefore we must act."]

# -----------------------------------------------------------------------------
# EXTERNAL CAPABILITIES - Plan #300
# -----------------------------------------------------------------------------
# External services that cost real money and require human approval.
# Agents can REQUEST capabilities, but they're only available after you:
# 1. Add the API key (directly or as ${ENV_VAR} reference)
# 2. Set enabled: true
#
# Example capabilities:
#
# external_capabilities:
#   openai_embeddings:
#     enabled: true
#     api_key: ${OPENAI_API_KEY}      # Read from environment variable
#     model: text-embedding-3-small
#     budget_limit: 10.00             # Optional spend limit in dollars
#
#   anthropic_api:
#     enabled: false                  # Disabled until you configure it
#     api_key: ${ANTHROPIC_API_KEY}
#     model: claude-3-haiku-20240307
#
# To see capability requests from agents, check the event log for
# "capability_request" events, or look in the dashboard.
# -----------------------------------------------------------------------------
external_capabilities: {}