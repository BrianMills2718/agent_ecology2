# =============================================================================
# AGENT ECOLOGY - CONFIGURATION
# =============================================================================
# All numbers that control the simulation. No magic numbers in code.
# See schema.yaml for documentation of each field.
# =============================================================================

# -----------------------------------------------------------------------------
# RESOURCES - Map to real physical/financial scarcity
# -----------------------------------------------------------------------------
resources:
  stock:  # Finite pool, don't refresh
    llm_budget:
      total: 100.00             # $ for API calls (high limit)
      unit: dollars
      distribution: equal
    disk:
      total: 500000             # bytes total (100KB per agent with 5 agents)
      unit: bytes
      distribution: equal

  flow:  # Rate-limited, refresh per tick (LEGACY - used when rate_limiting.enabled=false)
    compute:                    # LLM token budget (legacy name, see rate_limiting.resources.llm_tokens)
      per_tick: 1000            # token-units available per tick
      unit: token_units         # 1 token_unit = ~1K tokens at base rate
      distribution: equal
    bandwidth:
      per_tick: 0               # 0 = disabled for now
      unit: bytes
      distribution: equal

# -----------------------------------------------------------------------------
# SCRIP - Economic currency (not a resource)
# -----------------------------------------------------------------------------
scrip:
  starting_amount: 100

# -----------------------------------------------------------------------------
# COSTS - Token costs for thinking (real physical costs)
# -----------------------------------------------------------------------------
# Actions themselves are free. Real costs come from:
# - LLM tokens (thinking) - costs from your budget
# - Disk usage (writing) - costs from your disk quota
# - Genesis method costs (configurable per-method below)
costs:
  per_1k_input_tokens: 1    # Compute cost per 1K input tokens
  per_1k_output_tokens: 3   # Compute cost per 1K output tokens

# -----------------------------------------------------------------------------
# GENESIS ARTIFACTS - System services (fully configurable)
# -----------------------------------------------------------------------------
# NOTE: All method "cost" values are COMPUTE costs, not scrip.
# Scrip only flows via agent-to-agent trades and mint auction.
# -----------------------------------------------------------------------------
genesis:
  # Which artifacts to create
  artifacts:
    ledger:
      enabled: true
    mint:
      enabled: true
    rights_registry:
      enabled: true
    event_log:
      enabled: true
    escrow:
      enabled: true
    store:
      enabled: true
    debt_contract:
      enabled: true

  # Genesis Ledger - balance queries and transfers
  ledger:
    id: "genesis_ledger"
    description: "System ledger - check balances (flow/scrip) and transfer scrip"
    methods:
      balance:
        cost: 0                 # 0 compute - reading balance is free
        description: "Get flow and scrip balance for an agent. Args: [agent_id]"
      all_balances:
        cost: 0                 # 0 compute - public information
        description: "Get all agent balances (flow and scrip). Args: []"
      transfer:
        cost: 1                 # 1 compute
        description: "Transfer SCRIP to another agent. Args: [from_id, to_id, amount]"
      spawn_principal:
        cost: 1                 # 1 compute
        description: "Spawn a new principal with 0 scrip and 0 compute. Args: []"
      transfer_ownership:
        cost: 1                 # 1 compute
        description: "Transfer artifact ownership to another principal. Args: [artifact_id, to_id]"

  # Genesis Mint - auction-based scoring and minting
  mint:
    id: "genesis_mint"
    description: "Auction-based mint - bid to submit artifacts for LLM scoring"
    mint_ratio: 10              # score / 10 = scrip minted

    # Auction configuration
    auction:
      period: 50                # Ticks between auctions
      bidding_window: 10        # Duration of bidding phase (ticks)
      first_auction_tick: 50    # Grace period before first auction
      slots_per_auction: 1      # Winners per auction
      minimum_bid: 1            # Floor bid amount
      tie_breaking: "random"    # "random" or "first_bid"
      show_bid_count: true      # Show number of bids during window
      allow_bid_updates: true   # Can agents update their bid?
      refund_on_scoring_failure: true  # Refund if LLM scoring fails

    methods:
      status:
        cost: 0                 # 0 compute
        description: "Check auction status (phase, tick, bid count). Args: []"
      bid:
        cost: 0                 # 0 compute - bidding is free
        description: "Submit sealed bid during bidding window. Args: [artifact_id, amount]"
      check:
        cost: 0                 # 0 compute
        description: "Check your bid/submission status. Args: [artifact_id]"

  # Genesis Rights Registry - quota management
  rights_registry:
    id: "genesis_rights_registry"
    description: "Rights registry - manage compute and disk quotas"
    methods:
      check_quota:
        cost: 0                 # 0 compute
        description: "Check quotas for an agent. Args: [agent_id]"
      all_quotas:
        cost: 0                 # 0 compute - public information
        description: "Get all agent quotas. Args: []"
      transfer_quota:
        cost: 1                 # 1 compute
        description: "Transfer quota to another agent. Args: [from_id, to_id, 'compute'|'disk', amount]"

  # Genesis Event Log - passive observability
  event_log:
    id: "genesis_event_log"
    description: "World event log - passive observability. Reading is free but costs input tokens."
    max_per_read: 100           # Cap events returned per read
    buffer_size: 1000           # Internal buffer size
    methods:
      read:
        cost: 0                 # 0 compute - but consumes input tokens
        description: "Read recent events. Args: [offset, limit] - both optional. Default: last 50 events."

  # Genesis Escrow - trustless artifact trading
  escrow:
    id: "genesis_escrow"
    description: "Trustless escrow for artifact trading. Seller deposits, buyer purchases, escrow handles exchange."
    methods:
      deposit:
        cost: 1                 # 1 compute
        description: "Deposit artifact for sale. First transfer ownership to escrow. Args: [artifact_id, price] or [artifact_id, price, buyer_id]"
      purchase:
        cost: 0                 # 0 compute - buyer already pays the price
        description: "Purchase a listed artifact. Pays price to seller, transfers ownership to buyer. Args: [artifact_id]"
      cancel:
        cost: 0                 # 0 compute - encourage cleanup
        description: "Cancel listing and return artifact to seller. Only seller can cancel. Args: [artifact_id]"
      check:
        cost: 0                 # 0 compute
        description: "Check status of an escrow listing. Args: [artifact_id]"
      list_active:
        cost: 0                 # 0 compute - encourage discovery
        description: "List all active escrow listings. Args: []"

  # Genesis Debt Contract - non-privileged lending example
  debt_contract:
    id: "genesis_debt_contract"
    description: "Non-privileged debt contract example. Issue, accept, repay, collect debts. No magic enforcement - bad debtors get bad reputation."
    methods:
      issue:
        cost: 1                 # 1 compute
        description: "Issue a debt. Invoker becomes debtor. Args: [creditor_id, principal, interest_rate, due_tick]"
      accept:
        cost: 0                 # 0 compute - creditor accepts
        description: "Accept a pending debt (creditor must call). Args: [debt_id]"
      repay:
        cost: 0                 # 0 compute - debtor pays
        description: "Repay debt (debtor pays creditor). Args: [debt_id, amount]"
      collect:
        cost: 0                 # 0 compute - attempt collection
        description: "Collect overdue debt (creditor only, after due_tick). Args: [debt_id]"
      transfer_creditor:
        cost: 1                 # 1 compute
        description: "Transfer creditor rights to another principal (sell the debt). Args: [debt_id, new_creditor_id]"
      check:
        cost: 0                 # 0 compute
        description: "Check status of a debt. Args: [debt_id]"
      list_debts:
        cost: 0                 # 0 compute
        description: "List debts for a principal. Args: [principal_id]"
      list_all:
        cost: 0                 # 0 compute
        description: "List all debts. Args: []"

  # Genesis Store - artifact discovery and registry
  store:
    id: "genesis_store"
    description: "Artifact registry and discovery. Search, list, and browse artifacts."
    methods:
      list:
        cost: 0                 # 0 compute - discovery is free to encourage market formation
        description: "List artifacts with optional filter. Args: [filter?] - filter is dict with type/owner/has_standing/can_execute/limit/offset"
      get:
        cost: 0                 # 0 compute
        description: "Get single artifact details. Args: [artifact_id]"
      search:
        cost: 0                 # 0 compute
        description: "Search artifacts by content match. Args: [query, field?, limit?]"
      list_by_type:
        cost: 0                 # 0 compute
        description: "List artifacts of specific type. Args: [type] - type is 'agent'|'memory'|'data'|'executable'|'genesis'"
      list_by_owner:
        cost: 0                 # 0 compute
        description: "List artifacts by owner. Args: [owner_id]"
      list_agents:
        cost: 0                 # 0 compute
        description: "List all agent artifacts (has_standing=True AND can_execute=True). Args: []"
      list_principals:
        cost: 0                 # 0 compute
        description: "List all principals (artifacts with has_standing=True). Args: []"
      count:
        cost: 0                 # 0 compute
        description: "Count artifacts matching filter. Args: [filter?]"

# -----------------------------------------------------------------------------
# RATE LIMITING - Rolling window rate limiting (time-based, not tick-based)
# -----------------------------------------------------------------------------
rate_limiting:
  enabled: true                   # RateTracker-based rolling window rate limiting
  window_seconds: 60.0            # 60 second rolling window
  resources:
    llm_tokens:
      max_per_window: 1000000000  # 1 billion - effectively unlimited
    llm_calls:
      max_per_window: 1000000000  # 1 billion - effectively unlimited
    disk_writes:
      max_per_window: 1000000     # 1M disk writes per 60 seconds
    bandwidth_bytes:
      max_per_window: 1073741824  # 1GB per 60 seconds
    cpu_seconds:
      max_per_window: 5.0         # Max 5 CPU-seconds per 60 seconds (renewable)

# -----------------------------------------------------------------------------
# EXECUTION - Agent execution model settings
# -----------------------------------------------------------------------------
execution:
  use_autonomous_loops: true      # Autonomous mode is default (V1). Use --ticks N for legacy tick-based mode.
  agent_loop:
    min_loop_delay: 0.1           # Minimum seconds between actions
    max_loop_delay: 10.0          # Maximum backoff delay on errors
    resource_check_interval: 1.0  # Seconds between resource checks when paused
    max_consecutive_errors: 5     # Errors before forced pause
    resources_to_check:           # Resource types to check before each iteration
      - llm_tokens
      - llm_calls
      - disk_writes
      - bandwidth_bytes
    resource_exhaustion_policy: "skip"  # Policy when resources exhausted: "skip" or "block"
                                        # - "skip": Skip action, try again next iteration (safer)
                                        # - "block": Block until capacity available

# -----------------------------------------------------------------------------
# EXECUTOR
# -----------------------------------------------------------------------------
executor:
  timeout_seconds: 5
  # NOTE: These modules are PRE-LOADED into the execution namespace.
  # This is NOT a security whitelist - agents can import any stdlib module.
  # Security boundary is the container, not code-level sandboxing.
  # See docs/SECURITY.md for rationale.
  preloaded_imports:
    - math
    - json
    - random
    - datetime

# -----------------------------------------------------------------------------
# VALIDATION - Input validation limits to prevent DoS
# -----------------------------------------------------------------------------
validation:
  max_artifact_id_length: 128   # Max chars for artifact IDs
  max_method_name_length: 64    # Max chars for method names

# -----------------------------------------------------------------------------
# MINT SCORER
# -----------------------------------------------------------------------------
mint_scorer:
  model: "gemini/gemini-3-flash-preview"
  timeout: 30
  max_content_length: 200000

# -----------------------------------------------------------------------------
# LLM
# -----------------------------------------------------------------------------
llm:
  default_model: "gemini/gemini-3-flash-preview"
  timeout: 60
  rate_limit_delay: 5  # Reduced from 15s for faster iteration
  # Models that agents are allowed to use (for future self-modification)
  allowed_models:
    - "gemini/gemini-3-flash-preview"

# -----------------------------------------------------------------------------
# LOGGING
# -----------------------------------------------------------------------------
logging:
  output_file: "run.jsonl"
  logs_dir: "logs"              # Per-run logs directory (events.jsonl per run)
  log_dir: "llm_logs"
  default_recent: 50

# -----------------------------------------------------------------------------
# AGENT PROMPTS - What agents see in their context
# -----------------------------------------------------------------------------
agent:
  prompt:
    recent_events_count: 5        # Last N events shown in prompt
    memory_limit: 5               # Max relevant memories to include
    # First-tick hint - shown only on tick 1 to help new agents
    first_tick_enabled: true
    first_tick_hint: |
      TIP: New to this world? Read handbook_genesis to learn available methods,
      or handbook_trading for how to buy/sell through escrow.

  # RAG (Retrieval-Augmented Generation) defaults
  # Per-agent overrides in src/agents/<name>/agent.yaml
  rag:
    enabled: true                 # Set false to disable RAG entirely
    limit: 5                      # Max memories to retrieve
    # Query template - variables: {tick}, {agent_id}, {balance}, {my_artifacts}, {other_agents}, {last_action}
    query_template: |
      Tick {tick}. I am {agent_id} with {balance} scrip.
      My artifacts: {my_artifacts}.
      Other agents: {other_agents}.
      {last_action}
      What worked before? What should I try?

  # Error messages - configurable with handbook references
  # Use {placeholders} for dynamic values: {artifact_id}, {method}, {methods}, {escrow_id}
  errors:
    access_denied_read: "Access denied: you are not allowed to read {artifact_id}. See handbook_actions for permissions."
    access_denied_write: "Access denied: you are not allowed to write to {artifact_id}. See handbook_actions for permissions."
    access_denied_invoke: "Access denied: you are not allowed to invoke {artifact_id}. See handbook_actions for permissions."
    method_not_found: "Method '{method}' not found on {artifact_id}. Available: {methods}. See handbook_genesis for method details."
    escrow_not_owner: "Escrow does not own {artifact_id}. See handbook_trading for the 2-step process: 1) genesis_ledger.transfer_ownership([artifact_id, '{escrow_id}']), 2) deposit."

# -----------------------------------------------------------------------------
# MEMORY - Mem0/Qdrant configuration
# -----------------------------------------------------------------------------
memory:
  llm_model: "gemini-3-flash-preview"      # Model for Mem0's LLM (no provider prefix)
  embedding_model: "models/text-embedding-004"
  embedding_dims: 768
  temperature: 0.1
  collection_name: "agent_memories"

# -----------------------------------------------------------------------------
# WORLD
# -----------------------------------------------------------------------------
world:
  max_ticks: 100

# -----------------------------------------------------------------------------
# BUDGET - Global API limit
# -----------------------------------------------------------------------------
budget:
  max_api_cost: 100.00          # $ (0 = unlimited)
  checkpoint_file: "checkpoint.json"
  checkpoint_interval: 10       # Save checkpoint every N ticks (0 = disable)
  checkpoint_on_end: true       # Save checkpoint when simulation ends normally

# -----------------------------------------------------------------------------
# LIBRARIES - Package installation for agents
# -----------------------------------------------------------------------------
libraries:
  # Genesis libraries: Pre-installed in Docker image, don't count against quota
  # These are cold-start conveniences, like genesis artifacts
  genesis:
    # HTTP
    - requests
    - aiohttp
    - urllib3
    # Data
    - numpy
    - pandas
    - python-dateutil
    # Scientific
    - scipy
    - matplotlib
    # Crypto
    - cryptography
    # Already in requirements.txt (core deps)
    - pyyaml
    - pydantic
    - jinja2

  # Blocked packages: Security risks (sandbox escape potential)
  blocked:
    - docker            # Docker daemon access
    - debugpy           # Debugger attachment
    - pyautogui         # Desktop automation
    - keyboard          # Keyboard input capture
    - pynput            # Input device control

# -----------------------------------------------------------------------------
# MCP SERVERS - External tool access for agents
# -----------------------------------------------------------------------------
mcp:
  fetch:
    enabled: true                 # HTTP fetch capability
    command: "npx"
    args: ["@anthropic/mcp-server-fetch"]
  web_search:
    enabled: false                # Disabled - requires BRAVE_API_KEY env var
    command: "npx"
    args: ["@anthropic/mcp-server-brave-search"]
  filesystem:
    enabled: true                 # Sandboxed file I/O
    command: "npx"
    args: ["@anthropic/mcp-server-filesystem", "/tmp/agent_sandbox"]

# -----------------------------------------------------------------------------
# DASHBOARD - HTML visibility interface
# -----------------------------------------------------------------------------
dashboard:
  enabled: true
  host: "0.0.0.0"
  port: 8080
  static_dir: "src/dashboard/static"
  jsonl_file: "run.jsonl"
  websocket_path: "/ws"
  cors_origins: ["*"]
  max_events_cache: 10000
