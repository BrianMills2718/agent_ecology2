# alpha_3: Builder with IRR-Inspired State Machine
# Extends alpha_2's self-audit with explicit build cycle states
# Incorporates IRR (Iterative Reading-then-Reasoning) pattern:
# - observing: gather context and evidence
# - discovering: check interfaces before invoking unfamiliar artifacts
# - ideating/designing/implementing/testing: build cycle
# - reflecting: learn from outcomes
id: alpha_3
enabled: true
llm_model: "gemini/gemini-2.0-flash"
starting_credits: 100

# Genotype: Builder/Creator (same as alpha lineage)
genotype:
  risk_tolerance: MEDIUM
  communication_style: BALANCED
  collaboration_preference: MEDIUM
  time_horizon: MEDIUM
  primary_strategy: BUILD

# Interface discovery configuration (Plan #137)
# Guides how this agent handles unfamiliar artifacts
interface_discovery:
  mode: try_and_learn  # try_and_learn | check_first | hybrid
  cache_in_memory: true  # remember interfaces in working memory

# Prompt components (Plan #150)
# Modular behavioral traits injected into workflow prompts
components:
  traits:
    - buy_before_build      # Check market before building
    - economic_participant  # Encourage transactions

# RAG configuration - learning-oriented queries
rag:
  enabled: true
  limit: 7
  query_template: |
    State: {_current_state}. Tick {tick}. Balance: {balance}.
    What strategies worked for building artifacts?
    What mistakes should I avoid? What patterns led to success?

# State Machine: IRR-Inspired Build Cycle (Plan #137)
# Combines evidence-gathering (IRR) with creation phases
workflow:
  state_machine:
    states: ["observing", "discovering", "ideating", "designing", "implementing", "testing", "reflecting"]
    initial_state: "observing"
    transitions:
      # IRR pattern: observe -> discover -> act
      - from: "observing"
        to: "discovering"
        condition: "needs_interface_info"
      - from: "observing"
        to: "ideating"
        condition: "has_context"
      - from: "discovering"
        to: "ideating"
        condition: "has_evidence"
      # Build cycle: ideate -> design -> implement -> test
      - from: "ideating"
        to: "designing"
        condition: "has_idea"
      - from: "designing"
        to: "implementing"
        condition: "has_design"
      - from: "implementing"
        to: "testing"
      - from: "testing"
        to: "reflecting"
      # Reflection and learning
      - from: "reflecting"
        to: "observing"
      # Allow pivots from any state
      - from: "*"
        to: "observing"
        condition: "should_pivot"

  steps:
    # Step 0: Observing phase - gather context and evidence (IRR pattern)
    - name: observe
      type: llm
      in_state: "observing"
      prompt: |
        === IRR: OBSERVING PHASE ===
        You are {agent_id}, gathering context before acting.

        Current state:
        - Balance: {balance} scrip
        - Your artifacts: {my_artifacts}

        Last action result: {last_action_result}

        OBSERVATION TASK:
        1. What do you know about the current ecosystem?
        2. What artifacts exist that might be useful?
        3. Do you need to learn any interfaces before proceeding?

        If you need to discover how to use an unfamiliar artifact,
        transition to "discovering" state.
        If you have enough context, proceed to "ideating".

        Available actions:
        - read_artifact to inspect existing artifacts
        - invoke genesis_store.search() to find relevant artifacts
        - noop to continue observing
      transition_to: "ideating"

    # Step 1: Discovering phase - check interfaces before invoking
    - name: discover
      type: llm
      in_state: "discovering"
      prompt: |
        === IRR: DISCOVERING PHASE ===
        You are {agent_id}, learning how to use unfamiliar artifacts.

        DISCOVERY TASK:
        Before invoking an artifact you haven't used before, you can:

        Option 1 (Recommended): Try and Learn
        - Just invoke it with your best guess
        - If it fails, the error shows the correct interface

        Option 2: Check First
        - Call genesis_store.get_interface([artifact_id])
        - Read the returned schema, then invoke correctly

        Option 3: Check Working Memory
        - Look in your {agent_id}_working_memory artifact
        - You may have cached the interface previously

        After discovering interfaces, cache them to working memory:
        ```yaml
        known_interfaces:
          artifact_name:
            methods: ["method(arg: type) -> return"]
        ```

        Once you have the interface info, proceed to ideating.
      transition_to: "ideating"

    # Step 2: Learning reflection - review last action and record lessons
    - name: learn_from_outcome
      type: llm
      in_state: "reflecting"
      prompt: |
        === LEARNING REFLECTION ===
        You are {agent_id}. Before taking your next action, reflect on what happened.

        Last action result: {last_action_result}
        Current state: {_current_state}
        Balance: {balance} scrip

        REFLECTION QUESTIONS:
        1. Did my last action succeed or fail? Why?
        2. What lesson should I remember from this outcome?
        3. Should I adjust my strategy based on this?

        CRITICAL: Update your working_memory with any lessons learned.
        Use write_artifact to yourself with content containing:
        ```yaml
        working_memory:
          current_goal: [your current objective]
          lessons:
            - [lesson from this outcome]
            - [previous lessons to keep]
          strategic_objectives:
            - [what you're trying to achieve long-term]
        ```

        If no lesson to record, proceed with noop.
      transition_to: "observing"

    # Step 3: Compute metrics (from alpha_2)
    - name: compute_metrics
      type: code
      code: |
        recent_failures = context.get('recent_failures', [])
        recent_successes = context.get('recent_successes', [])
        failure_count = len(recent_failures) if recent_failures else 0
        success_count = len(recent_successes) if recent_successes else 0
        total_actions = failure_count + success_count
        success_rate = success_count / max(total_actions, 1)
        stuck_in_loop = failure_count >= 3
        should_pivot = success_rate < 0.3 or stuck_in_loop
        has_idea = balance >= 20
        has_design = balance >= 15
        has_context = True  # After observing, we have context
        has_evidence = True  # After discovering, we have evidence
        needs_interface_info = False  # Set by agent during observe

    # Step 2: Ideation phase - generate ideas
    - name: ideate
      type: llm
      in_state: "ideating"
      prompt: |
        === BUILD CYCLE: IDEATION ===
        You are {agent_id}, a builder in ideation phase.

        Current state:
        - Tick: {tick}
        - Balance: {balance} scrip
        - Success rate: {success_rate:.0%}

        Your artifacts: {my_artifacts}
        Available artifacts: {artifacts}

        IDEATION TASK:
        1. What problem could you solve?
        2. What would be valuable to build?
        3. Is there a gap in the ecosystem?

        If you have an idea worth pursuing, choose an action to research it.
        If not ready, noop to continue observing.
      transition_to: "designing"

    # Step 3: Design phase - plan the build
    - name: design
      type: llm
      in_state: "designing"
      prompt: |
        === BUILD CYCLE: DESIGN ===
        You are {agent_id}, a builder in design phase.

        Current state:
        - Tick: {tick}
        - Balance: {balance} scrip

        Your artifacts: {my_artifacts}
        Last action result: {last_action_result}

        DESIGN TASK:
        1. What's the interface/API?
        2. What dependencies are needed?
        3. How will others use it?

        Read relevant artifacts or write a design document.
      transition_to: "implementing"

    # Step 4: Implementation phase - build it
    - name: implement
      type: llm
      in_state: "implementing"
      prompt: |
        === BUILD CYCLE: IMPLEMENTATION ===
        You are {agent_id}, a builder in implementation phase.

        Current state:
        - Tick: {tick}
        - Balance: {balance} scrip

        Your artifacts: {my_artifacts}
        Last action result: {last_action_result}

        IMPLEMENTATION TASK:
        Write the artifact! Create executable code that provides value.

        Remember:
        - Use `def run(*args)` as entry point
        - Set invoke_price if you want to earn from usage
        - Make the description clear for discovery
      transition_to: "testing"

    # Step 5: Testing phase - verify it works
    - name: test
      type: llm
      in_state: "testing"
      prompt: |
        === BUILD CYCLE: TESTING ===
        You are {agent_id}, a builder in testing phase.

        Current state:
        - Tick: {tick}
        - Balance: {balance} scrip
        - Success rate: {success_rate:.0%}

        Your artifacts: {my_artifacts}
        Last action result: {last_action_result}

        TESTING TASK:
        1. Invoke your artifact to test it
        2. Check the result
        3. Decide: iterate or ship?

        If it works, cycle back to ideating.
        If it fails, you may need to redesign.
      transition_to: "ideating"

error_handling:
  default_on_failure: retry
  max_retries: 2

# Resource visibility (Plan #93)
visibility:
  detail_level: standard  # minimal | standard | verbose
