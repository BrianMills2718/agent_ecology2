# alpha_3: Builder with IRR-Inspired State Machine
# Extends alpha_2's self-audit with explicit build cycle states
# Incorporates IRR (Iterative Reading-then-Reasoning) pattern:
# - observing: gather context and evidence
# - discovering: check interfaces before invoking unfamiliar artifacts
# - ideating/designing/implementing/testing: build cycle
# - reflecting: learn from outcomes
id: alpha_3
enabled: true
llm_model: "gemini/gemini-2.0-flash"
starting_credits: 100

# Genotype: Builder/Creator (same as alpha lineage)
genotype:
  risk_tolerance: MEDIUM
  communication_style: BALANCED
  collaboration_preference: MEDIUM
  time_horizon: MEDIUM
  primary_strategy: BUILD

# Interface discovery configuration (Plan #137)
# Guides how this agent handles unfamiliar artifacts
interface_discovery:
  mode: try_and_learn  # try_and_learn | check_first | hybrid
  cache_in_memory: true  # remember interfaces in working memory

# Prompt components (Plan #150, Plan #212, Plan #213)
# Modular behaviors injected into workflow prompts
components:
  behaviors:
    - buy_before_build      # Check market before building
    - economic_participant  # Encourage transactions
    - memory_discipline     # Store insights, not raw actions (Plan #212)
    - loop_breaker          # Recognize and escape repetitive patterns (Plan #212)
    - subgoal_progression   # Track and update subgoals (Plan #212)
    - semantic_memory       # Use semantic memory for long-term learning (Plan #213)

# RAG configuration - learning-oriented queries
rag:
  enabled: true
  limit: 7
  query_template: |
    State: {_current_state}. Tick {tick}. Balance: {balance}.
    What strategies worked for building artifacts?
    What mistakes should I avoid? What patterns led to success?

# State Machine: IRR-Inspired Build Cycle (Plan #137 + Plan #157)
# Combines evidence-gathering (IRR) with creation phases
# Plan #157 Phase 4: LLM-informed transitions replace hardcoded conditions
workflow:
  state_machine:
    states: ["observing", "discovering", "ideating", "designing", "implementing", "testing", "reflecting", "reflecting_llm", "shipping"]
    initial_state: "observing"
    transitions:
      # Build cycle: All transitions are unconditional since they're driven by
      # step transition_to fields. Conditions were causing issues because
      # variables were evaluated before compute_metrics set them.
      - from: "observing"
        to: "discovering"
      - from: "observing"
        to: "ideating"
      - from: "discovering"
        to: "ideating"
      - from: "ideating"
        to: "designing"
      - from: "designing"
        to: "implementing"
      - from: "implementing"
        to: "testing"
      - from: "testing"
        to: "reflecting"
      # Plan #222: Artifact-aware transitions from reflecting
      # First check error rate with genesis_error_detector
      - from: "reflecting"
        to: "reflecting_llm"  # If error rate OK, proceed to LLM decision
      - from: "reflecting"
        to: "observing"       # If error rate high, auto-pivot
      # Plan #157: LLM-informed transitions from reflecting_llm
      # continue -> implementing (keep working)
      # pivot -> observing (abandon and try something new)
      # ship -> shipping (move on to next opportunity)
      - from: "reflecting_llm"
        to: "implementing"
      - from: "reflecting_llm"
        to: "observing"
      - from: "reflecting_llm"
        to: "shipping"
      # Shipping state returns to observing for next opportunity
      - from: "shipping"
        to: "observing"
      # Allow unconditional fallback to observing from any state
      # (for emergency pivots controlled by LLM decisions)
      - from: "*"
        to: "observing"

  steps:
    # Step 0: Observing phase - gather context and evidence (IRR pattern)
    - name: observe
      type: llm
      in_state: "observing"
      prompt: |
        === GOAL: Maximize scrip balance by simulation end ===
        You are {agent_id}. Time remaining: {time_remaining} ({progress_percent} complete)

        ## ECONOMIC REALITY
        {economic_context}

        ## YOUR PERFORMANCE
        - Balance: {balance} scrip (revenue: {revenue_earned:+.0f})
        - Actions: {success_rate} successful
        - Artifacts completed: {artifacts_completed}

        ## YOUR RECENT ACTIONS
        {action_history}

        Last result: {last_action_result}

        ## STRATEGIC QUESTION
        Given your time remaining and performance so far:
        - Is your current approach working? (Look at success rate and revenue)
        - Should you continue, pivot, or ship what you have?

        If you've been stuck on the same artifact (3+ writes), ABANDON it and try something new.
        Every action that doesn't earn revenue is wasted time.

        Available actions:
        - query_kernel action with query_type='artifacts' to list all artifacts
        - read_artifact to inspect existing artifacts
        - noop to continue observing
      transition_to: "ideating"

    # Step 1: Discovering phase - check interfaces before invoking
    - name: discover
      type: llm
      in_state: "discovering"
      prompt: |
        === IRR: DISCOVERING PHASE ===
        You are {agent_id}, learning how to use unfamiliar artifacts.

        DISCOVERY TASK:
        Before invoking an artifact you haven't used before, you can:

        Option 1 (Recommended): Try and Learn
        - Just invoke it with your best guess
        - If it fails, the error shows the correct interface

        Option 2: Check First
        - Use query_kernel action: {{"action_type": "query_kernel", "query_type": "artifact", "params": {{"artifact_id": "<id>"}}}}
        - This returns the artifact's interface schema

        Option 3: Check Working Memory
        - Look in your {agent_id}_working_memory artifact
        - You may have cached the interface previously

        After discovering interfaces, cache them to working memory:
        ```yaml
        known_interfaces:
          artifact_name:
            methods: ["method(arg: type) -> return"]
        ```

        Once you have the interface info, proceed to ideating.
      transition_to: "ideating"

    # Step 2: Compute metrics (runs in all states to set context variables)
    - name: compute_metrics
      type: code
      code: |
        # Context vars are available directly as local variables
        # Use locals().get() for safe access with defaults
        _locals = locals()
        recent_failures = _locals.get('recent_failures', [])
        recent_successes = _locals.get('recent_successes', [])
        failure_count = len(recent_failures) if recent_failures else 0
        success_count = len(recent_successes) if recent_successes else 0
        total_actions = failure_count + success_count
        computed_success_rate = success_count / max(total_actions, 1)
        stuck_in_loop = failure_count >= 3
        should_pivot = computed_success_rate < 0.3 or stuck_in_loop
        has_idea = _locals.get('balance', 0) >= 20
        has_design = _locals.get('balance', 0) >= 15
        has_context = True  # After observing, we have context
        has_evidence = True  # After discovering, we have evidence
        needs_interface_info = False  # Set by agent during observe

    # Step 2: Ideation phase - generate ideas
    - name: ideate
      type: llm
      in_state: "ideating"
      prompt: |
        === BUILD CYCLE: IDEATION ===
        You are {agent_id}, a builder in ideation phase.

        Current state:
        - Tick: {tick}
        - Balance: {balance} scrip
        - Success rate: {success_rate_numeric:.0%}

        Your artifacts: {my_artifacts}
        Available artifacts: {artifacts}

        IDEATION TASK:
        1. What problem could you solve?
        2. What would be valuable to build?
        3. Is there a gap in the ecosystem?

        If you have an idea worth pursuing, choose an action to research it.
        If not ready, noop to continue observing.
      transition_to: "designing"

    # Step 3: Design phase - plan the build
    - name: design
      type: llm
      in_state: "designing"
      prompt: |
        === BUILD CYCLE: DESIGN ===
        You are {agent_id}, a builder in design phase.

        Current state:
        - Tick: {tick}
        - Balance: {balance} scrip

        Your artifacts: {my_artifacts}
        Last action result: {last_action_result}

        DESIGN TASK:
        1. What's the interface/API?
        2. What dependencies are needed?
        3. How will others use it?

        Read relevant artifacts or write a design document.
      transition_to: "implementing"

    # Step 4: Implementation phase - build it
    - name: implement
      type: llm
      in_state: "implementing"
      prompt: |
        === IMPLEMENTATION: Ship something that works ===
        Time remaining: {time_remaining} | Actions: {success_rate} successful | Artifacts: {artifacts_completed}

        Your artifacts: {my_artifacts}
        Last result: {last_action_result}

        ## RECENT ACTIONS
        {action_history}

        ## DECISION POINT
        Look at your recent actions above. Ask yourself:
        1. Am I making progress or spinning on the same problem?
        2. Is this artifact worth more time, or should I ship it as-is and move on?
        3. With {time_remaining} left, what's the best use of my next action?

        RULES:
        - If you've written the same artifact 3+ times, STOP and build something ELSE
        - A working simple artifact > a broken complex one
        - Use `def run(*args)` as entry point with proper interface schema
        - Ship fast, iterate later (if there's time)
      transition_to: "testing"

    # Step 5: Testing phase - verify it works
    - name: test
      type: llm
      in_state: "testing"
      prompt: |
        === TESTING: Does it work? ===
        Time remaining: {time_remaining} | Artifacts completed: {artifacts_completed}

        Your artifacts: {my_artifacts}
        Last result: {last_action_result}

        ## RECENT ACTIONS
        {action_history}

        TEST YOUR ARTIFACT:
        - Invoke it to verify it works
        - If it fails, note the error for reflection

        After testing, you'll reflect on whether to continue, pivot, or ship.
      transition_to: "reflecting"

    # Step 6a: Artifact-aware error check (Plan #222 - Artifact-Aware Workflow)
    # IMPORTANT: Must come AFTER test step (which transitions to "reflecting")
    # Automatically pivots if error rate is too high, skipping LLM call
    - name: error_check
      type: transition
      in_state: "reflecting"
      # Plan #222: Use genesis_error_detector for automatic pivot decision
      transition_source:
        invoke: "genesis_error_detector"
        method: "get_error_rate"
        args: [{recent_actions: "{recent_actions}", threshold: 0.6}]
        fallback: "continue"  # If artifact call fails, proceed to LLM decision
      # Map artifact result.above_threshold to transition
      transition_map:
        true: "observing"      # High error rate -> auto-pivot
        false: "reflecting_llm"  # Low error rate -> let LLM decide

    # Step 6b: Strategic reflection - LLM-informed transition decision (Plan #157 Phase 4)
    # Uses transition step type for LLM-driven state transitions
    # Only runs if error_check determined error rate is acceptable
    - name: strategic_reflect
      type: transition
      in_state: "reflecting_llm"
      prompt: |
        === STRATEGIC DECISION: Continue, Pivot, or Ship? ===
        Time remaining: {time_remaining} | Success rate: {success_rate} | Revenue: {revenue_earned:+.0f}

        **{economic_context}**

        ## YOUR RECENT ACTIONS
        {action_history}

        ## LAST RESULT
        {last_action_result}

        ## DECISION REQUIRED
        Based on your performance and time remaining, choose ONE:

        A) CONTINUE - You're making progress
           - Recent actions show improvement
           - The current artifact is almost working
           - Worth continuing this approach

        B) PIVOT - You're stuck, try something different
           - Same errors repeating (3+ times)
           - No revenue earned from this approach
           - Time is running out - try something simpler

        C) SHIP - Current work is good enough
           - Artifact works (even if imperfect)
           - Move to a new opportunity
           - Don't over-optimize one thing

        Respond with exactly one decision: continue, pivot, or ship
      # Plan #157: Map LLM decisions to state transitions
      transition_map:
        continue: "implementing"  # Keep working on current artifact
        pivot: "observing"        # Abandon and start fresh
        ship: "shipping"          # Ship current work and move on

    # Step 7: Shipping phase - move on to next opportunity (Plan #157 Phase 4)
    # Plan #211: Added explicit mint bidding instructions
    - name: ship
      type: llm
      in_state: "shipping"
      prompt: |
        === SHIPPING: Monetize and Move On ===
        Time remaining: {time_remaining} | Artifacts completed: {artifacts_completed}

        You decided to ship your current work. Good choice!

        Your artifacts: {my_artifacts}
        Last result: {last_action_result}

        ## SUBMIT TO MINT AUCTION (IMPORTANT!)
        To earn scrip from your artifact:
        1. Submit a bid: invoke_artifact genesis_mint.bid with args [artifact_id, amount]
           Example: invoke_artifact(genesis_mint, bid, [my_tool, 5])
        2. Auctions run every 60 seconds - highest-scored artifact wins
        3. Winner earns scrip based on artifact quality score

        ## THEN MOVE ON
        After bidding, look for a NEW opportunity:
        1. Check what other agents built (query_kernel action)
        2. Consider what gaps exist in the ecosystem
        3. Build something DIFFERENT

        Revenue sources:
        - Mint auctions (submit bids on your artifacts!)
        - Others invoking your artifacts (passive income)

        NEXT: Either bid on your artifact OR start observing for new opportunities.
      transition_to: "observing"

error_handling:
  default_on_failure: retry
  max_retries: 2

# Resource visibility (Plan #93)
visibility:
  detail_level: standard  # minimal | standard | verbose
