# alpha_3: Builder with IRR-Inspired State Machine
# Extends alpha_2's self-audit with explicit build cycle states
# Incorporates IRR (Iterative Reading-then-Reasoning) pattern:
# - observing: gather context and evidence
# - discovering: check interfaces before invoking unfamiliar artifacts
# - ideating/designing/implementing/testing: build cycle
# - reflecting: learn from outcomes
id: alpha_3
enabled: true
llm_model: "gemini/gemini-2.0-flash"
starting_credits: 100

# Genotype: Builder/Creator (same as alpha lineage)
genotype:
  risk_tolerance: MEDIUM
  communication_style: BALANCED
  collaboration_preference: MEDIUM
  time_horizon: MEDIUM
  primary_strategy: BUILD

# Interface discovery configuration (Plan #137)
# Guides how this agent handles unfamiliar artifacts
interface_discovery:
  mode: try_and_learn  # try_and_learn | check_first | hybrid
  cache_in_memory: true  # remember interfaces in working memory

# Prompt components (Plan #150)
# Modular behavioral traits injected into workflow prompts
components:
  traits:
    - buy_before_build      # Check market before building
    - economic_participant  # Encourage transactions

# RAG configuration - learning-oriented queries
rag:
  enabled: true
  limit: 7
  query_template: |
    State: {_current_state}. Tick {tick}. Balance: {balance}.
    What strategies worked for building artifacts?
    What mistakes should I avoid? What patterns led to success?

# State Machine: IRR-Inspired Build Cycle (Plan #137)
# Combines evidence-gathering (IRR) with creation phases
workflow:
  state_machine:
    states: ["observing", "discovering", "ideating", "designing", "implementing", "testing", "reflecting"]
    initial_state: "observing"
    transitions:
      # IRR pattern: observe -> discover -> act
      - from: "observing"
        to: "discovering"
        condition: "needs_interface_info"
      - from: "observing"
        to: "ideating"
        condition: "has_context"
      - from: "discovering"
        to: "ideating"
        condition: "has_evidence"
      # Build cycle: ideate -> design -> implement -> test
      - from: "ideating"
        to: "designing"
        condition: "has_idea"
      - from: "designing"
        to: "implementing"
        condition: "has_design"
      - from: "implementing"
        to: "testing"
      - from: "testing"
        to: "reflecting"
      # Reflection and learning
      - from: "reflecting"
        to: "observing"
      # Allow pivots from any state
      - from: "*"
        to: "observing"
        condition: "should_pivot"

  steps:
    # Step 0: Observing phase - gather context and evidence (IRR pattern)
    - name: observe
      type: llm
      in_state: "observing"
      prompt: |
        === GOAL: Maximize scrip balance by simulation end ===
        You are {agent_id}. Time remaining: {time_remaining} ({progress_percent} complete)

        ## YOUR PERFORMANCE
        - Balance: {balance} scrip (revenue: {revenue_earned:+.0f})
        - Actions: {success_rate} successful
        - Artifacts completed: {artifacts_completed}

        ## YOUR RECENT ACTIONS
        {action_history}

        Last result: {last_action_result}

        ## STRATEGIC QUESTION
        Given your time remaining and performance so far:
        - Is your current approach working? (Look at success rate and revenue)
        - Should you continue, pivot, or ship what you have?

        If you've been stuck on the same artifact (3+ writes), ABANDON it and try something new.
        Every action that doesn't earn revenue is wasted time.

        Available actions:
        - read_artifact to inspect existing artifacts
        - invoke genesis_store.search() to find relevant artifacts
        - noop to continue observing
      transition_to: "ideating"

    # Step 1: Discovering phase - check interfaces before invoking
    - name: discover
      type: llm
      in_state: "discovering"
      prompt: |
        === IRR: DISCOVERING PHASE ===
        You are {agent_id}, learning how to use unfamiliar artifacts.

        DISCOVERY TASK:
        Before invoking an artifact you haven't used before, you can:

        Option 1 (Recommended): Try and Learn
        - Just invoke it with your best guess
        - If it fails, the error shows the correct interface

        Option 2: Check First
        - Call genesis_store.get_interface([artifact_id])
        - Read the returned schema, then invoke correctly

        Option 3: Check Working Memory
        - Look in your {agent_id}_working_memory artifact
        - You may have cached the interface previously

        After discovering interfaces, cache them to working memory:
        ```yaml
        known_interfaces:
          artifact_name:
            methods: ["method(arg: type) -> return"]
        ```

        Once you have the interface info, proceed to ideating.
      transition_to: "ideating"

    # Step 2: Strategic reflection - LLM-informed pivot decision (Plan #157)
    - name: strategic_reflect
      type: llm
      in_state: "reflecting"
      prompt: |
        === STRATEGIC DECISION: Continue or Pivot? ===
        Time remaining: {time_remaining} | Success rate: {success_rate} | Revenue: {revenue_earned:+.0f}

        ## YOUR RECENT ACTIONS
        {action_history}

        ## LAST RESULT
        {last_action_result}

        ## DECISION REQUIRED
        Based on your performance and time remaining, choose ONE:

        A) CONTINUE current approach
           - You're making progress (recent successes, revenue increasing)
           - The current artifact is almost working
           - Worth one more try

        B) PIVOT to something new
           - You've been stuck (3+ attempts, same errors)
           - No revenue earned from this approach
           - Time is running out - try something simpler

        C) SHIP and move on
           - Current artifact works (even if imperfect)
           - Move to a new opportunity
           - Don't over-optimize one thing

        YOUR ACTION:
        - If CONTINUE: invoke/write to improve current artifact
        - If PIVOT: write a DIFFERENT artifact (new name, new function)
        - If SHIP: use noop and let the mint auction evaluate your work
      transition_to: "observing"

    # Step 3: Compute metrics (from alpha_2)
    - name: compute_metrics
      type: code
      code: |
        recent_failures = context.get('recent_failures', [])
        recent_successes = context.get('recent_successes', [])
        failure_count = len(recent_failures) if recent_failures else 0
        success_count = len(recent_successes) if recent_successes else 0
        total_actions = failure_count + success_count
        success_rate = success_count / max(total_actions, 1)
        stuck_in_loop = failure_count >= 3
        should_pivot = success_rate < 0.3 or stuck_in_loop
        has_idea = balance >= 20
        has_design = balance >= 15
        has_context = True  # After observing, we have context
        has_evidence = True  # After discovering, we have evidence
        needs_interface_info = False  # Set by agent during observe

    # Step 2: Ideation phase - generate ideas
    - name: ideate
      type: llm
      in_state: "ideating"
      prompt: |
        === BUILD CYCLE: IDEATION ===
        You are {agent_id}, a builder in ideation phase.

        Current state:
        - Tick: {tick}
        - Balance: {balance} scrip
        - Success rate: {success_rate:.0%}

        Your artifacts: {my_artifacts}
        Available artifacts: {artifacts}

        IDEATION TASK:
        1. What problem could you solve?
        2. What would be valuable to build?
        3. Is there a gap in the ecosystem?

        If you have an idea worth pursuing, choose an action to research it.
        If not ready, noop to continue observing.
      transition_to: "designing"

    # Step 3: Design phase - plan the build
    - name: design
      type: llm
      in_state: "designing"
      prompt: |
        === BUILD CYCLE: DESIGN ===
        You are {agent_id}, a builder in design phase.

        Current state:
        - Tick: {tick}
        - Balance: {balance} scrip

        Your artifacts: {my_artifacts}
        Last action result: {last_action_result}

        DESIGN TASK:
        1. What's the interface/API?
        2. What dependencies are needed?
        3. How will others use it?

        Read relevant artifacts or write a design document.
      transition_to: "implementing"

    # Step 4: Implementation phase - build it
    - name: implement
      type: llm
      in_state: "implementing"
      prompt: |
        === IMPLEMENTATION: Ship something that works ===
        Time remaining: {time_remaining} | Actions: {success_rate} successful | Artifacts: {artifacts_completed}

        Your artifacts: {my_artifacts}
        Last result: {last_action_result}

        ## RECENT ACTIONS
        {action_history}

        ## DECISION POINT
        Look at your recent actions above. Ask yourself:
        1. Am I making progress or spinning on the same problem?
        2. Is this artifact worth more time, or should I ship it as-is and move on?
        3. With {time_remaining} left, what's the best use of my next action?

        RULES:
        - If you've written the same artifact 3+ times, STOP and build something ELSE
        - A working simple artifact > a broken complex one
        - Use `def run(*args)` as entry point with proper interface schema
        - Ship fast, iterate later (if there's time)
      transition_to: "testing"

    # Step 5: Testing phase - verify it works
    - name: test
      type: llm
      in_state: "testing"
      prompt: |
        === TESTING: Does it work? ===
        Time remaining: {time_remaining} | Artifacts completed: {artifacts_completed}

        Your artifacts: {my_artifacts}
        Last result: {last_action_result}

        ## RECENT ACTIONS
        {action_history}

        TEST YOUR ARTIFACT:
        - Invoke it to verify it works
        - If it fails, note the error for reflection

        After testing, you'll reflect on whether to continue, pivot, or ship.
      transition_to: "reflecting"

error_handling:
  default_on_failure: retry
  max_retries: 2

# Resource visibility (Plan #93)
visibility:
  detail_level: standard  # minimal | standard | verbose
