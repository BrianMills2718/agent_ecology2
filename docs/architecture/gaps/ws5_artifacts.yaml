# WS-5: Artifacts & Executor Gap Analysis
# Comparing current artifacts_executor.md against target 05_contracts.md
#
# Created: 2026-01-12
# Methodology: docs/architecture/GAP_IDENTIFICATION_METHODOLOGY.md

metadata:
  workstream: WS-5
  component: artifacts_executor
  current_doc: docs/architecture/current/artifacts_executor.md
  target_doc: docs/architecture/target/05_contracts.md
  analyst: Claude Opus 4.5
  date: 2026-01-12

gaps:

  # =============================================================================
  # DATA MODEL GAPS
  # =============================================================================

  - id: GAP-ART-001
    component: artifacts_executor
    dimension: data_model
    title: "Replace policy field with access_contract_id"
    current_state: |
      Artifacts have an inline `policy` dict with fields:
        - read_price: int
        - invoke_price: int
        - allow_read: list
        - allow_write: list
        - allow_invoke: list
      Access control is directly embedded in each artifact.
    target_state: |
      Artifacts have a single `access_contract_id` field pointing to a contract
      artifact that governs all permissions. No inline policy.
      Every artifact has an access_contract_id (required field).
    delta: |
      - Remove the `policy` dict field from Artifact dataclass
      - Add `access_contract_id: str` field (required)
      - Migrate existing artifacts to use genesis_freeware contract by default
      - Update ArtifactStore.write() to require access_contract_id
    dependencies:
      - GAP-ART-003  # Genesis contracts must exist first
    complexity: M
    risk: high
    files_affected:
      - src/world/artifacts.py
      - src/world/genesis.py
      - tests/test_artifacts.py
    acceptance_criteria:
      - Artifact dataclass has access_contract_id field, no policy field
      - All artifacts created with access_contract_id
      - Migration path for existing artifacts documented

  - id: GAP-ART-002
    component: artifacts_executor
    dimension: data_model
    title: "Add contract interface and has_standing fields"
    current_state: |
      Artifacts have `executable: bool` and `code: str` fields.
      No formal interface declaration or standing concept.
    target_state: |
      Contract artifacts have:
        - has_loop: True
        - has_standing: False (contracts don't need standing)
        - interface: { tools: [{ name, inputSchema, ... }] }
      Interface declares available tools including check_permission.
    delta: |
      - Add `has_standing: bool` field to Artifact (default True for agents, False for contracts)
      - Add `interface: dict` field for declaring tool signatures
      - Executable contracts should declare their check_permission interface
    dependencies: []
    complexity: M
    risk: medium
    files_affected:
      - src/world/artifacts.py
      - src/world/genesis.py
    acceptance_criteria:
      - Artifacts have has_standing and interface fields
      - Contract artifacts declare check_permission in interface
      - Non-contract artifacts have empty interface

  - id: GAP-ART-003
    component: artifacts_executor
    dimension: data_model
    title: "Add contract cache_policy field"
    current_state: |
      No caching mechanism for permission checks.
      Every access check re-evaluates the policy.
    target_state: |
      Contracts declare cache_policy:
        - cacheable: bool
        - ttl_seconds: int
        - cache_key: list of fields
      System caches permission results based on contract policy.
    delta: |
      - Add cache_policy field to contract artifacts
      - Implement permission cache with TTL expiry
      - Implement cache invalidation on artifact/contract changes
    dependencies:
      - GAP-ART-001  # access_contract_id must exist
    complexity: L
    risk: medium
    files_affected:
      - src/world/artifacts.py
      - src/world/executor.py
      - src/world/world.py
    acceptance_criteria:
      - Contracts can declare cache_policy
      - Permission results cached per cache_key
      - Cache invalidated on artifact content change
      - Cache invalidated on contract change

  - id: GAP-ART-004
    component: artifacts_executor
    dimension: data_model
    title: "Add cost_model field to contracts"
    current_state: |
      Cost model is simple: executor.cost_per_ms for execution time.
      No per-contract cost model specification.
    target_state: |
      Contracts specify cost_model: "invoker_pays" | "owner_pays" | "artifact_pays" | "split"
      Contract logic can also dynamically determine who pays via charge() function.
    delta: |
      - Add cost_model field to contract artifacts
      - Implement cost routing based on cost_model
      - Support dynamic charging via charge() in contract namespace
    dependencies:
      - GAP-ART-012  # Contract execution namespace
    complexity: M
    risk: medium
    files_affected:
      - src/world/artifacts.py
      - src/world/executor.py
      - src/world/ledger.py
    acceptance_criteria:
      - Contracts can specify cost_model
      - Costs routed to correct principal based on cost_model
      - charge(principal, amount) available in contract namespace

  # =============================================================================
  # CAPABILITIES GAPS
  # =============================================================================

  - id: GAP-ART-005
    component: artifacts_executor
    dimension: capabilities
    title: "Implement check_permission contract invocation flow"
    current_state: |
      Permission checks use inline policy:
        - can_read(agent_id) checks allow_read list
        - can_write(agent_id) checks allow_write list
        - can_invoke(agent_id) checks allow_invoke list
      @contract references raise NotImplementedError.
    target_state: |
      Permission checks invoke the access contract:
        1. Look up artifact.access_contract_id
        2. Invoke contract.check_permission({artifact_id, action, requester_id})
        3. Contract returns {allowed: bool, reason: str}
        4. If allowed: proceed; if not: return error
    delta: |
      - Implement contract invocation for permission checks
      - Replace can_read/can_write/can_invoke with contract invocation
      - Pass full context to check_permission (artifact_id, action, requester_id)
    dependencies:
      - GAP-ART-001  # access_contract_id field
      - GAP-ART-012  # Contract execution namespace
    complexity: L
    risk: high
    files_affected:
      - src/world/artifacts.py
      - src/world/executor.py
      - src/world/actions.py
    acceptance_criteria:
      - All permission checks invoke access contract
      - check_permission receives artifact_id, action, requester_id
      - Contract response determines access
      - NotImplementedError for @contract removed

  - id: GAP-ART-006
    component: artifacts_executor
    dimension: capabilities
    title: "Create genesis contracts (freeware, self_owned, private, public)"
    current_state: |
      Genesis artifacts exist (ledger, oracle, store, escrow, event_log, handbook).
      No genesis access contracts exist.
    target_state: |
      Four genesis contracts:
        - genesis_freeware: anyone reads/invokes, only creator writes/deletes
        - genesis_self_owned: only the artifact itself can access
        - genesis_private: only creator has any access
        - genesis_public: anyone can do anything
    delta: |
      - Create genesis_freeware contract with check_permission implementation
      - Create genesis_self_owned contract
      - Create genesis_private contract
      - Create genesis_public contract
      - Register all in genesis initialization
    dependencies:
      - GAP-ART-002  # Contract interface field
    complexity: M
    risk: low
    files_affected:
      - src/world/genesis.py
      - tests/test_genesis.py
    acceptance_criteria:
      - All four genesis contracts exist after initialization
      - Each implements check_permission correctly
      - genesis_freeware is the default for new artifacts

  - id: GAP-ART-007
    component: artifacts_executor
    dimension: capabilities
    title: "Support delete and transfer actions in permission checks"
    current_state: |
      Access control supports: read, write, invoke.
      No delete or transfer action types.
    target_state: |
      Action types include: read, write, invoke, delete, transfer.
      check_permission receives action enum including all five types.
    delta: |
      - Add delete action type
      - Add transfer action type
      - Update all permission check callsites
      - Genesis contracts handle all five actions
    dependencies:
      - GAP-ART-005  # check_permission flow
    complexity: S
    risk: low
    files_affected:
      - src/world/artifacts.py
      - src/world/actions.py
      - src/world/genesis.py
    acceptance_criteria:
      - delete action triggers permission check
      - transfer action triggers permission check
      - Genesis contracts return appropriate response for each

  - id: GAP-ART-008
    component: artifacts_executor
    dimension: capabilities
    title: "Remove kernel-level owner bypass"
    current_state: |
      Owner always has access in can_read/can_write/can_invoke methods:
        "Owner always has access" (artifacts.py:118-136)
        "Owner ALWAYS has write access (bypasses policy)" (artifacts.py:138-160)
    target_state: |
      No kernel-level owner bypass. access_contract_id is the ONLY authority.
      If you want owner-based access, your contract implements it.
      The kernel doesn't know what an "owner" is.
    delta: |
      - Remove owner bypass logic from can_read/can_write/can_invoke
      - All access goes through contract check_permission
      - Owner concept implemented in contracts (genesis_freeware checks created_by)
    dependencies:
      - GAP-ART-005  # check_permission flow
    complexity: M
    risk: high
    files_affected:
      - src/world/artifacts.py
    acceptance_criteria:
      - No special owner handling in Artifact class
      - Owner access works via genesis_freeware contract
      - Tests verify owner has no backdoor access

  - id: GAP-ART-009
    component: artifacts_executor
    dimension: capabilities
    title: "Implement contract composition patterns"
    current_state: |
      No contract composition. Access control is per-artifact policy.
    target_state: |
      Two composition patterns:
        1. Pre-computed composition: caller evaluates each contract (AND logic)
           artifact.access_contracts is a list of contract IDs
        2. Meta-contract: single contract encodes composition logic internally
    delta: |
      - Support access_contracts list (multiple contracts) or access_contract_id (single)
      - Implement caller-side AND composition
      - Document meta-contract pattern for complex cases
    dependencies:
      - GAP-ART-005  # check_permission flow
    complexity: M
    risk: medium
    files_affected:
      - src/world/artifacts.py
      - src/world/executor.py
    acceptance_criteria:
      - Artifacts can have multiple access contracts
      - All contracts must allow for access to be granted
      - First denial stops evaluation

  # =============================================================================
  # INTERFACE GAPS
  # =============================================================================

  - id: GAP-ART-010
    component: artifacts_executor
    dimension: interfaces
    title: "Standardize check_permission interface"
    current_state: |
      No standard check_permission interface.
      Permission methods are can_read(agent_id), can_write(agent_id), can_invoke(agent_id).
    target_state: |
      Standard check_permission interface:
        Input: {artifact_id: str, action: enum, requester_id: str}
        Output: {allowed: bool, reason: str}
      All contracts must implement this interface.
    delta: |
      - Define PermissionRequest and PermissionResult types
      - All contracts implement check_permission with standard signature
      - Update executor to call check_permission with structured input
    dependencies: []
    complexity: S
    risk: low
    files_affected:
      - src/world/artifacts.py
      - src/world/executor.py
    acceptance_criteria:
      - PermissionRequest/PermissionResult types defined
      - check_permission signature documented
      - Contract validation checks interface

  - id: GAP-ART-011
    component: artifacts_executor
    dimension: interfaces
    title: "Add LLM invocation to contract namespace"
    current_state: |
      Executor provides: get_balance(), pay(), invoke().
      No LLM access from contract code.
    target_state: |
      Contracts have full capabilities including:
        - call_llm(prompt, model) for LLM queries
      Contracts are just executable artifacts - LLMs are API calls like weather APIs.
    delta: |
      - Add call_llm function to contract execution namespace
      - LLM costs charged per contract's cost_model
      - Non-determinism accepted (system already non-deterministic)
    dependencies:
      - GAP-ART-004  # cost_model field
    complexity: M
    risk: medium
    files_affected:
      - src/world/executor.py
      - src/agents/llm.py
    acceptance_criteria:
      - call_llm available in contract namespace
      - LLM costs tracked and charged
      - Contracts can make LLM queries

  - id: GAP-ART-012
    component: artifacts_executor
    dimension: interfaces
    title: "Expand contract execution namespace"
    current_state: |
      execute_with_wallet provides: get_balance(), pay()
      execute_with_invoke adds: invoke()
      Basic imports: math, json, random, datetime
    target_state: |
      Contract namespace includes:
        - invoke(artifact_id, args): Call another artifact
        - call_llm(prompt, model): Query LLM
        - charge(principal, amount): Charge scrip
        - get_artifact_info(id): Read artifact metadata
        - get_balance(principal, resource): Check balance
        - now(): Current timestamp
      Explicitly NOT available:
        - open(), os.*, subprocess.* (no filesystem)
        - socket.*, urllib.* (no direct network)
        - __import__ (no dynamic imports)
        - eval(), compile() (no nested code execution)
    delta: |
      - Add charge() function for contract-controlled payments
      - Add get_artifact_info() for metadata reads
      - Add now() for timestamp access
      - Add call_llm() for LLM access
      - Restrict dangerous builtins (__import__, eval, compile, open)
      - Document restricted namespace
    dependencies: []
    complexity: L
    risk: high
    files_affected:
      - src/world/executor.py
    acceptance_criteria:
      - All listed functions available in namespace
      - Dangerous builtins blocked
      - Contracts cannot access filesystem
      - Contracts cannot make direct network calls

  # =============================================================================
  # BEHAVIOR GAPS
  # =============================================================================

  - id: GAP-ART-013
    component: artifacts_executor
    dimension: behaviors
    title: "Implement permission check depth limit"
    current_state: |
      Invoke depth limit exists: MAX_INVOKE_DEPTH = 5.
      No separate permission check depth limit.
    target_state: |
      Separate permission depth limit: MAX_PERMISSION_DEPTH = 10.
      Prevents: Contract A invokes B -> B's check invokes C -> C's check invokes A.
      Permission checks track depth and fail if exceeded.
    delta: |
      - Add MAX_PERMISSION_DEPTH constant (10)
      - Track depth in check_permission calls
      - Return {allowed: False, reason: "Permission check depth exceeded"} on overflow
    dependencies:
      - GAP-ART-005  # check_permission flow
    complexity: S
    risk: low
    files_affected:
      - src/world/executor.py
      - config/schema.yaml
    acceptance_criteria:
      - Depth tracked across permission checks
      - Circular permission chains detected and rejected
      - Configurable depth limit

  - id: GAP-ART-014
    component: artifacts_executor
    dimension: behaviors
    title: "Implement contract timeout sandbox"
    current_state: |
      Executor has timeout_seconds (default 5).
      Basic timeout via multiprocessing.
    target_state: |
      Contract-specific timeout: CONTRACT_TIMEOUT_SECONDS = 30.
      Async wait_for pattern with proper cleanup.
      Timeout returns: {allowed: False, reason: "Contract execution timeout"}
    delta: |
      - Add CONTRACT_TIMEOUT_SECONDS config (30)
      - Implement async timeout for contract execution
      - Return standardized timeout error
      - Ensure resources cleaned up on timeout
    dependencies: []
    complexity: M
    risk: medium
    files_affected:
      - src/world/executor.py
      - config/schema.yaml
    acceptance_criteria:
      - Contract execution respects timeout
      - Timeout returns permission denied
      - Resources cleaned up on timeout

  - id: GAP-ART-015
    component: artifacts_executor
    dimension: behaviors
    title: "Implement fail-closed error handling for contracts"
    current_state: |
      Executor returns {success: False, error: str} on errors.
      No specific contract error handling.
    target_state: |
      Contract errors:
        - Logged but not exposed to requester
        - Return {allowed: False, reason: "Contract execution error"}
        - Fail closed: errors deny permission by default
      No result returned = denied.
    delta: |
      - Catch all exceptions in contract execution
      - Log error details internally
      - Return generic denied response to requester
      - Handle missing result as denial
    dependencies:
      - GAP-ART-005  # check_permission flow
    complexity: S
    risk: low
    files_affected:
      - src/world/executor.py
    acceptance_criteria:
      - Contract exceptions caught and logged
      - Requester sees generic error
      - Missing result treated as denial
      - Fail closed verified by tests

  - id: GAP-ART-016
    component: artifacts_executor
    dimension: behaviors
    title: "Implement base permission check cost model"
    current_state: |
      All execution costs based on time: cost_per_ms * execution_time_ms.
      No concept of free base checks.
    target_state: |
      Base permission checks are FREE:
        - Simple logic checks: 0 cost
        - Contract calls LLM: invoker pays LLM cost
        - Contract invokes artifacts: invoker pays invoke cost
      Rationale: checking if you have compute requires compute -> infinite regress.
    delta: |
      - Base check_permission execution has no compute cost
      - Only external calls (LLM, invoke) cost the invoker
      - Document cost model in code comments
    dependencies:
      - GAP-ART-005  # check_permission flow
    complexity: M
    risk: medium
    files_affected:
      - src/world/executor.py
      - src/world/ledger.py
    acceptance_criteria:
      - Simple permission checks are free
      - LLM calls in contracts cost invoker
      - Artifact invocations in contracts cost invoker

  # =============================================================================
  # CONFIGURATION GAPS
  # =============================================================================

  - id: GAP-ART-017
    component: artifacts_executor
    dimension: configuration
    title: "Add contract execution configuration"
    current_state: |
      Config: executor.timeout_seconds, executor.preloaded_imports, executor.cost_per_ms.
    target_state: |
      Additional contract config:
        - executor.contract_timeout_seconds (30)
        - executor.max_permission_depth (10)
        - executor.permission_cache_ttl (3600 default)
    delta: |
      - Add contract_timeout_seconds to schema
      - Add max_permission_depth to schema
      - Add permission_cache_ttl to schema
      - Update executor to use new config
    dependencies: []
    complexity: S
    risk: low
    files_affected:
      - config/schema.yaml
      - config/config.yaml
      - src/world/executor.py
    acceptance_criteria:
      - All new config options in schema
      - Defaults match target doc values
      - Executor uses configured values

  # =============================================================================
  # CONSTRAINT GAPS
  # =============================================================================

  - id: GAP-ART-018
    component: artifacts_executor
    dimension: constraints
    title: "Add contract namespace restrictions"
    current_state: |
      Preloaded imports for convenience: math, json, random, datetime.
      No explicit blocklist of dangerous functions.
      Security boundary is Docker container.
    target_state: |
      Explicit restrictions in contract namespace:
        - NO: open(), os.*, subprocess.* (filesystem/process)
        - NO: socket.*, urllib.* (direct network)
        - NO: __import__ (dynamic imports)
        - NO: eval(), compile() (nested code execution)
      Must use provided APIs (invoke, call_llm) for external access.
    delta: |
      - Create blocklist of dangerous builtins
      - Remove from execution namespace
      - Verify via tests that blocked functions raise errors
    dependencies:
      - GAP-ART-012  # Expanded namespace
    complexity: M
    risk: medium
    files_affected:
      - src/world/executor.py
    acceptance_criteria:
      - open() raises error in contract code
      - os module not accessible
      - __import__ blocked
      - eval/compile blocked
      - Tests verify all restrictions

  - id: GAP-ART-019
    component: artifacts_executor
    dimension: constraints
    title: "Implement resource limits for contracts"
    current_state: |
      Resource tracking: execution_time_ms, cost calculation.
      No explicit memory or CPU limits at contract level.
    target_state: |
      Contract resource limits:
        - CPU: Contracts run in worker pool with rate limits
        - Memory: Worker process memory limits apply
        - No disk access
        - No network access except through APIs
    delta: |
      - Implement worker pool for contract execution
      - Add memory limits per worker
      - Add rate limiting for contract executions
      - Document resource constraints
    dependencies: []
    complexity: L
    risk: medium
    files_affected:
      - src/world/executor.py
    acceptance_criteria:
      - Contracts run in isolated workers
      - Memory limits enforced
      - Rate limiting prevents abuse

  - id: GAP-ART-020
    component: artifacts_executor
    dimension: constraints
    title: "Handle dangling contract references"
    current_state: |
      No handling for missing contracts.
      @contract references raise NotImplementedError.
    target_state: |
      Three options identified (undecided):
        1. Fail-open: treat deleted contract as public
        2. Fail-closed: no access if contract missing
        3. Prevent deletion: can't delete referenced contracts
      Current position: undecided, deferred to implementation.
    delta: |
      - Decide on dangling contract behavior
      - Implement chosen approach
      - Handle case where access_contract_id points to deleted artifact
      - Document decision in DESIGN_CLARIFICATIONS.md
    dependencies:
      - GAP-ART-001  # access_contract_id field
    complexity: M
    risk: high
    files_affected:
      - src/world/artifacts.py
      - src/world/actions.py
      - docs/DESIGN_CLARIFICATIONS.md
    acceptance_criteria:
      - Dangling contract reference behavior defined
      - System handles missing contracts gracefully
      - Behavior documented

  - id: GAP-ART-021
    component: artifacts_executor
    dimension: constraints
    title: "Accept orphan artifact risk"
    current_state: |
      Artifacts can only be inaccessible if policy explicitly denies.
      Owner bypass prevents permanent lockout.
    target_state: |
      Orphan artifacts are ACCEPTED risk:
        - Broken contract chains = permanently inaccessible
        - Circular contract dependencies = permanently locked
        - No automatic rescue mechanism
      Rationale:
        1. Many loops are valuable (partnerships, multi-sig)
        2. Detection is impossible (external state, LLM, time)
        3. Trustlessness requires no backdoors
      Consequence: creators responsible for careful access design.
    delta: |
      - Remove owner bypass (GAP-ART-008)
      - Document orphan artifact risk
      - Add examples of circular dependency scenarios
      - Accept this as intended behavior
    dependencies:
      - GAP-ART-008  # Remove owner bypass
    complexity: S
    risk: high
    files_affected:
      - docs/DESIGN_CLARIFICATIONS.md
      - docs/architecture/current/artifacts_executor.md
    acceptance_criteria:
      - Orphan artifact risk documented
      - No backdoor access for locked artifacts
      - Warning in contract creation documentation

  # =============================================================================
  # MIGRATION GAPS
  # =============================================================================

  - id: GAP-ART-022
    component: artifacts_executor
    dimension: behaviors
    title: "Implement policy to contract migration"
    current_state: |
      Existing artifacts have policy fields.
      No contract-based access control.
    target_state: |
      Breaking changes required:
        - Remove policy field from Artifact
        - Add access_contract_id field (required)
        - Permission checks become contract invocations
      Preserved:
        - Owner concept (moved to contracts)
        - Access control logic (moved to contract code)
    delta: |
      - Create migration script for existing artifacts
      - Map policy patterns to genesis contracts
      - Update all artifact creation code
      - Update all permission check code
      - Document migration process
    dependencies:
      - GAP-ART-001  # access_contract_id field
      - GAP-ART-006  # Genesis contracts
    complexity: L
    risk: high
    files_affected:
      - src/world/artifacts.py
      - src/world/genesis.py
      - src/world/actions.py
      - tests/test_artifacts.py
    acceptance_criteria:
      - Migration script converts policy to access_contract_id
      - Existing tests pass after migration
      - No policy field references remain
      - Documentation updated

summary:
  total_gaps: 22
  by_dimension:
    data_model: 4
    capabilities: 5
    interfaces: 3
    behaviors: 5
    configuration: 1
    constraints: 4
  by_complexity:
    S: 5
    M: 11
    L: 5
    XL: 1
  by_risk:
    low: 5
    medium: 10
    high: 7
  critical_path:
    - GAP-ART-001  # access_contract_id field (foundation)
    - GAP-ART-006  # Genesis contracts
    - GAP-ART-010  # check_permission interface
    - GAP-ART-012  # Contract namespace
    - GAP-ART-005  # Permission check flow
    - GAP-ART-008  # Remove owner bypass
