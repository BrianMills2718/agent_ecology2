# WS-3 Resources Gap Analysis
# Generated: 2026-01-12
# Methodology: GAP_IDENTIFICATION_METHODOLOGY.md
# Sources:
#   Current: docs/architecture/current/resources.md
#   Target: docs/architecture/target/04_resources.md

metadata:
  workstream: WS-3
  component: resources
  created: 2026-01-12
  methodology: GAP_IDENTIFICATION_METHODOLOGY.md
  sources:
    current: docs/architecture/current/resources.md
    target: docs/architecture/target/04_resources.md

gaps:
  # =============================================================================
  # CAPABILITIES GAPS
  # =============================================================================

  - id: GAP-RES-001
    component: resources
    dimension: capabilities
    title: "Missing RateTracker class for rolling window rate limiting"
    current_state: |
      Resources reset at tick boundaries via discrete per-tick refresh.
      World.advance_tick() resets flow resources to quota at start of each tick.
      Use-or-lose model with no rolling window tracking.
    target_state: |
      RateTracker class with rolling window-based rate limiting:
      - rate: Units per minute (allocated)
      - window_seconds: Rolling window size (e.g., 60)
      - usage_log: (timestamp, amount) entries
      - can_use(), use(), usage_in_window() methods
      Renewable resources enforce rate only, no burst capacity.
    delta: |
      Implement RateTracker class with:
      - Rolling window usage tracking
      - Timestamp-based pruning of old entries
      - Rate capacity checking
      Replace tick-based reset with continuous rate enforcement.
    dependencies: []
    complexity: L
    risk: high
    files_affected:
      - src/world/ledger.py
      - src/world/world.py
      - src/world/simulation_engine.py
    acceptance_criteria:
      - RateTracker class exists with can_use(), use(), usage_in_window() methods
      - Rolling window correctly tracks usage over configurable time period
      - Old usage entries are pruned automatically
      - Tick-based reset is removed for renewable resources

  - id: GAP-RES-002
    component: resources
    dimension: capabilities
    title: "Missing CPU resource tracking"
    current_state: |
      No CPU resource tracking exists.
      Only llm_tokens (compute) is tracked as a flow resource.
      No measurement of actual CPU usage per action.
    target_state: |
      CPU tracked as renewable resource (CPU-seconds per wall-clock second).
      Per-agent CPU rate allocation.
      Measurement using resource.getrusage(RUSAGE_SELF) in worker processes.
      CPU allocation is tradeable between agents.
    delta: |
      Add CPU as a renewable resource type with:
      - Per-agent rate allocation in config
      - Integration with worker pool for measurement
      - Trading support via ledger transfers
    dependencies:
      - GAP-RES-001
      - GAP-RES-008
    complexity: L
    risk: medium
    files_affected:
      - src/world/ledger.py
      - config/schema.yaml
      - config/config.yaml
    acceptance_criteria:
      - CPU resource type defined in config
      - CPU usage measured via getrusage in worker processes
      - CPU allocation tradeable between agents
      - Per-agent CPU rate limits enforced

  - id: GAP-RES-003
    component: resources
    dimension: capabilities
    title: "Missing Memory resource tracking"
    current_state: |
      No memory resource tracking exists.
      Memory is not considered as a resource type.
    target_state: |
      Memory tracked as allocatable resource (bytes).
      Per-agent memory tracking using tracemalloc.
      Peak memory per action charged to agent.
      Docker --memory limit enforces actual constraint.
    delta: |
      Implement memory tracking with:
      - tracemalloc integration in action execution
      - Peak memory measurement per action
      - Per-agent memory usage ledger entries
    dependencies:
      - GAP-RES-008
    complexity: M
    risk: medium
    files_affected:
      - src/world/ledger.py
      - src/world/world.py
      - src/world/simulation_engine.py
    acceptance_criteria:
      - Memory tracked using tracemalloc
      - Peak memory per action recorded
      - Per-agent memory visible in metrics
      - Memory quota enforcement before operations

  - id: GAP-RES-004
    component: resources
    dimension: capabilities
    title: "Missing LLM rate limit tracking (distinct from budget)"
    current_state: |
      LLM budget tracked as system-wide $ limit.
      Per-tick compute quota exists but is not rate-limiting.
      No tokens-per-minute (TPM) enforcement.
    target_state: |
      LLM rate limit as renewable resource (tokens/minute).
      Provider limit partitioned across agents.
      Rate allocation tradeable via ledger.
      Distinct from LLM API $ budget (depletable).
    delta: |
      Add LLM rate limit as separate resource from budget:
      - TPM allocation per agent from provider limit
      - Rolling window rate enforcement
      - Trading of rate allocation
    dependencies:
      - GAP-RES-001
    complexity: M
    risk: medium
    files_affected:
      - src/world/ledger.py
      - src/world/simulation_engine.py
      - config/schema.yaml
    acceptance_criteria:
      - LLM rate distinct from LLM budget in config
      - Per-agent TPM allocation from provider limit
      - Rate limits enforced with rolling window
      - Rate allocation tradeable

  - id: GAP-RES-005
    component: resources
    dimension: capabilities
    title: "Missing GPU resource tracking"
    current_state: |
      No GPU resource tracking exists.
      No support for local GPU LLMs.
    target_state: |
      GPU tracked as renewable resource (GPU-seconds per wall-clock second).
      Allocation via nvidia-smi or pynvml.
      Traded like CPU allocation.
      Model server pattern for GPU-based LLMs.
    delta: |
      Add GPU resource support:
      - GPU rate allocation in config
      - nvidia-smi/pynvml integration for measurement
      - Trading support via ledger
      - Model server pattern documentation
    dependencies:
      - GAP-RES-001
    complexity: L
    risk: low
    files_affected:
      - src/world/ledger.py
      - config/schema.yaml
    acceptance_criteria:
      - GPU resource type defined
      - GPU usage measurable via nvidia-smi/pynvml
      - GPU allocation tradeable
      - Model server pattern documented

  - id: GAP-RES-006
    component: resources
    dimension: capabilities
    title: "Missing debt artifact model for scrip borrowing"
    current_state: |
      Scrip cannot go negative - hard constraint.
      No borrowing mechanism exists.
      Transfer fails if sender lacks funds.
    target_state: |
      Scrip balance stays >= 0 but debt handled via debt artifacts:
      - B transfers scrip to A (actual transfer)
      - Debt artifact created: "A owes B X scrip"
      - B owns the tradeable debt artifact
      Like M1 vs M2 money - debt instruments separate from base currency.
    delta: |
      Implement debt artifact system:
      - Debt artifact type with debtor, creditor, amount
      - Creation workflow for loans
      - Trading of debt artifacts
      - Optional: enforcement/collection mechanisms
    dependencies: []
    complexity: L
    risk: medium
    files_affected:
      - src/world/artifacts.py
      - src/world/genesis.py
      - src/world/ledger.py
    acceptance_criteria:
      - Debt artifacts can be created representing loans
      - Debt artifacts are tradeable
      - Scrip balance never goes negative
      - Debt separate from base currency

  - id: GAP-RES-007
    component: resources
    dimension: capabilities
    title: "Missing external resource abstraction (web search, external APIs)"
    current_state: |
      Only LLM API is modeled as external resource.
      No abstraction for other external services.
    target_state: |
      Unified model for all external resources:
      - Web search (queries/min + budget)
      - External APIs (per-API limits + budget)
      - Any artifact can make external calls
      - genesis_web_search as bootstrap artifact
    delta: |
      Implement external resource abstraction:
      - Config structure for external APIs
      - Rate + budget dual tracking
      - Genesis artifacts for common services
      - Invoker-pays cost attribution
    dependencies:
      - GAP-RES-001
    complexity: L
    risk: low
    files_affected:
      - src/world/genesis.py
      - config/schema.yaml
    acceptance_criteria:
      - External API config structure exists
      - Web search resource type supported
      - Any artifact can make external calls
      - Costs attributed to invoker or artifact based on standing

  - id: GAP-RES-008
    component: resources
    dimension: capabilities
    title: "Missing ProcessPoolExecutor for action execution"
    current_state: |
      Actions executed synchronously in main process.
      No worker pool for isolated execution.
      No ability to measure CPU/memory accurately per action.
    target_state: |
      ProcessPoolExecutor with asyncio for action execution:
      - Workers measure resources via getrusage + tracemalloc
      - Non-blocking action execution
      - Workers compute, main process mutates world state
      - Pool size configurable (default: os.cpu_count())
    delta: |
      Implement worker pool execution:
      - ProcessPoolExecutor integration with asyncio
      - execute_in_worker() function with resource measurement
      - Artifact snapshot passing to workers
      - Main process orchestration of mutations
    dependencies: []
    complexity: XL
    risk: high
    files_affected:
      - src/world/world.py
      - src/world/simulation_engine.py
      - src/world/executor.py
      - config/schema.yaml
    acceptance_criteria:
      - ProcessPoolExecutor used for action execution
      - asyncio integration for non-blocking execution
      - CPU and memory measured in workers
      - Pool size configurable
      - Workers receive artifact snapshots, not live state

  - id: GAP-RES-009
    component: resources
    dimension: capabilities
    title: "Missing action serialization for worker processes"
    current_state: |
      Actions not designed for serialization.
      No pickling constraints on Action class.
    target_state: |
      Actions are pure data (picklable):
      - action_type, target_id, method, args
      - No lambda functions, file handles, closures
      - Complex state referenced by ID, loaded by worker
    delta: |
      Refactor Action class:
      - Ensure all fields are JSON-serializable
      - Add validation to reject non-picklable content
      - Document serialization constraints
    dependencies:
      - GAP-RES-008
    complexity: M
    risk: medium
    files_affected:
      - src/world/actions.py
    acceptance_criteria:
      - Action class is fully picklable
      - Validation rejects non-serializable content
      - Complex state passed by reference, not value

  - id: GAP-RES-010
    component: resources
    dimension: capabilities
    title: "Missing local LLM support (CPU and GPU inference)"
    current_state: |
      Only API-based LLMs supported.
      No local LLM inference support.
    target_state: |
      Support for both API and local LLMs:
      - Local CPU LLMs (llama.cpp) via worker pool
      - Local GPU LLMs (vLLM, TGI, Ollama) via model server
      - Unified cost attribution regardless of LLM type
    delta: |
      Add local LLM support:
      - Local CPU LLM integration (captured by getrusage)
      - Model server pattern for GPU LLMs
      - Configuration for LLM provider selection
    dependencies:
      - GAP-RES-008
      - GAP-RES-005
    complexity: L
    risk: low
    files_affected:
      - src/agents/llm.py
      - config/schema.yaml
    acceptance_criteria:
      - Local CPU LLM calls work through worker pool
      - GPU LLM model server pattern supported
      - LLM provider configurable (API vs local)

  # =============================================================================
  # DATA MODEL GAPS
  # =============================================================================

  - id: GAP-RES-011
    component: resources
    dimension: data_model
    title: "Resource terminology mismatch: 'compute' vs specific resource types"
    current_state: |
      Config uses "compute" for LLM token tracking.
      Internally stored as "llm_tokens" in Ledger.
      Single flow resource concept.
    target_state: |
      Clear terminology separation:
      - LLM API $ (depletable, USD)
      - LLM rate limit (renewable, tokens/min)
      - CPU (renewable, CPU-seconds)
      - Memory (allocatable, bytes)
      - Disk (allocatable, bytes)
      "Compute" reserved for local CPU only.
    delta: |
      Rename/split resources:
      - "compute" -> "cpu" for local compute
      - Add "llm_rate" for tokens/minute
      - Keep "llm_budget" for $ tracking
      - Update all config and code references
    dependencies: []
    complexity: M
    risk: medium
    files_affected:
      - config/schema.yaml
      - config/config.yaml
      - src/world/ledger.py
      - src/world/world.py
      - src/world/simulation_engine.py
    acceptance_criteria:
      - "compute" renamed to "cpu" throughout
      - LLM rate and LLM budget are distinct
      - All resource types have clear, distinct names
      - Config and code terminology aligned

  - id: GAP-RES-012
    component: resources
    dimension: data_model
    title: "Missing three-category resource classification"
    current_state: |
      Two-layer model: Resources (flow/stock) and Scrip.
      Flow = reset per tick, Stock = persistent.
    target_state: |
      Three resource categories:
      - Depletable: Once spent, gone forever (LLM API $)
      - Allocatable: Quota, reclaimable (Disk, Memory)
      - Renewable: Rate-limited via rolling window (CPU, LLM rate)
      Scrip is currency, not resource.
    delta: |
      Refactor resource classification:
      - Add category field to resource definitions
      - Implement category-specific behaviors
      - Update ledger to handle each category differently
    dependencies:
      - GAP-RES-001
    complexity: M
    risk: medium
    files_affected:
      - src/world/ledger.py
      - config/schema.yaml
    acceptance_criteria:
      - Resources tagged with category
      - Each category has distinct behavior
      - Ledger operations respect category semantics

  - id: GAP-RES-013
    component: resources
    dimension: data_model
    title: "Missing rate allocation storage in ledger"
    current_state: |
      Ledger stores balances and quotas.
      No concept of rate allocations.
      Rights registry manages simple quotas.
    target_state: |
      Rate allocation stored in ledger:
      - Per-agent rate for each renewable resource
      - Tradeable like any asset
      - Sum of allocations equals provider limit
    delta: |
      Add rate allocation to ledger:
      - New field type for rate allocations
      - Transfer support for rate allocations
      - Validation that allocations sum to provider limit
    dependencies:
      - GAP-RES-001
    complexity: M
    risk: medium
    files_affected:
      - src/world/ledger.py
      - src/world/genesis.py
    acceptance_criteria:
      - Rate allocations stored in ledger
      - Rate allocations transferable
      - System validates total allocation constraints

  - id: GAP-RES-014
    component: resources
    dimension: data_model
    title: "Missing ResourceUsage dataclass for worker measurements"
    current_state: |
      No structured type for resource usage measurements.
      Costs calculated inline.
    target_state: |
      ResourceUsage dataclass:
      - cpu_seconds: float
      - memory_bytes: int
      Returned from workers for deduction in main process.
    delta: |
      Add ResourceUsage dataclass and integrate with worker execution.
    dependencies:
      - GAP-RES-008
    complexity: S
    risk: low
    files_affected:
      - src/world/ledger.py
      - src/world/simulation_engine.py
    acceptance_criteria:
      - ResourceUsage dataclass exists
      - Workers return ResourceUsage with measurements
      - Main process uses ResourceUsage for deductions

  # =============================================================================
  # INTERFACES GAPS
  # =============================================================================

  - id: GAP-RES-015
    component: resources
    dimension: interfaces
    title: "Missing rate_tracker API methods"
    current_state: |
      Ledger has can_spend_resource() and can_afford_scrip().
      No rate-based capacity checking.
    target_state: |
      RateTracker API:
      - can_use(agent_id, resource_type, amount) -> bool
      - use(agent_id, resource_type, amount) -> bool
      - wait_for_capacity(agent_id, resource_type, amount) async
      - record_usage(agent_id, resource_type, amount)
    delta: |
      Implement RateTracker with full API including async wait_for_capacity.
    dependencies:
      - GAP-RES-001
    complexity: M
    risk: medium
    files_affected:
      - src/world/ledger.py
    acceptance_criteria:
      - All RateTracker methods implemented
      - Async wait_for_capacity works with rolling window
      - record_usage updates usage log

  - id: GAP-RES-016
    component: resources
    dimension: interfaces
    title: "Missing ledger.transfer for rate allocations"
    current_state: |
      Ledger.transfer_scrip() handles scrip transfers.
      No generic transfer for other resource types.
    target_state: |
      genesis_ledger.transfer(from, to, amount, resource_type):
      - Works for scrip, cpu, llm_rate, disk quota, memory quota
      - Unilateral (sender's right, no recipient consent)
    delta: |
      Extend ledger transfer API:
      - Generic transfer method for any resource type
      - Support for rate allocation transfers
      - Support for quota transfers
    dependencies:
      - GAP-RES-013
    complexity: M
    risk: medium
    files_affected:
      - src/world/ledger.py
      - src/world/genesis.py
    acceptance_criteria:
      - Generic transfer method exists
      - All resource types transferable
      - Transfers are unilateral (sender decides)

  - id: GAP-RES-017
    component: resources
    dimension: interfaces
    title: "Missing estimate_cost() function for pre-execution checks"
    current_state: |
      Costs calculated post-execution.
      No estimation before action.
    target_state: |
      estimate_cost(action) returns estimated resource costs:
      - Used for pre-execution rate limit checks
      - Actual usage may differ from estimate
      - No penalty for estimation errors
    delta: |
      Implement estimate_cost() function for actions.
    dependencies: []
    complexity: M
    risk: low
    files_affected:
      - src/world/simulation_engine.py
    acceptance_criteria:
      - estimate_cost() returns resource estimates
      - Used for pre-execution rate checks
      - Actual usage recorded separately

  # =============================================================================
  # BEHAVIORS GAPS
  # =============================================================================

  - id: GAP-RES-018
    component: resources
    dimension: behaviors
    title: "Tick-based reset vs rolling window rate limiting"
    current_state: |
      Flow resources reset at tick boundaries.
      Use-or-lose within single tick.
      advance_tick() calls set_resource() to reset quotas.
    target_state: |
      No tick-based reset for renewable resources.
      Rolling window rate limiting (continuous).
      Use it or lose it based on time window, not ticks.
    delta: |
      Remove tick-based reset for renewable resources:
      - advance_tick() no longer resets renewable resources
      - Rate limiting via rolling window instead
      - Tick boundaries only affect simulation state, not resource refresh
    dependencies:
      - GAP-RES-001
    complexity: M
    risk: high
    files_affected:
      - src/world/world.py
    acceptance_criteria:
      - advance_tick() does not reset renewable resources
      - Rolling window enforces rate limits
      - Existing tests updated for new behavior

  - id: GAP-RES-019
    component: resources
    dimension: behaviors
    title: "Action blocking when over rate limit vs skip"
    current_state: |
      If agent lacks compute, action not executed.
      Agent marked as insufficient_compute.
      Returns SkipResult.
    target_state: |
      If agent exceeds rate, action is queued:
      - await rate_tracker.wait_for_capacity()
      - Agent blocked until window rolls
      - No skip, just delay
    delta: |
      Change over-limit handling:
      - Replace skip with async wait
      - Queue actions when over rate
      - Execute when capacity available
    dependencies:
      - GAP-RES-001
      - GAP-RES-015
    complexity: L
    risk: high
    files_affected:
      - src/world/simulation_engine.py
      - src/world/world.py
    acceptance_criteria:
      - Over-rate actions wait instead of skip
      - Async wait for capacity implemented
      - Actions execute when window rolls

  - id: GAP-RES-020
    component: resources
    dimension: behaviors
    title: "Missing invocation cost model (has_standing-based payment)"
    current_state: |
      Artifact prices paid on read/invoke.
      No distinction based on artifact standing.
    target_state: |
      Payment follows has_standing property:
      - has_standing=true: Artifact pays its own costs
      - has_standing=false: Invoker pays
      Nested invocations follow same rules.
    delta: |
      Implement standing-based cost attribution:
      - Check has_standing on invocation
      - Route costs appropriately
      - Handle nested invocation chains
    dependencies: []
    complexity: M
    risk: medium
    files_affected:
      - src/world/executor.py
      - src/world/world.py
    acceptance_criteria:
      - has_standing checked on invocation
      - Costs attributed based on standing
      - Nested invocations work correctly

  - id: GAP-RES-021
    component: resources
    dimension: behaviors
    title: "Missing permission check cost attribution"
    current_state: |
      Permission checks may have costs but attribution unclear.
    target_state: |
      Requester pays for permission checks:
      - Every action involves permission check
      - Permission check cost paid by requester
      - Separate from action execution cost
    delta: |
      Implement permission check cost attribution:
      - Track permission check cost separately
      - Always charge requester
      - Distinct from action execution cost
    dependencies:
      - GAP-RES-020
    complexity: S
    risk: low
    files_affected:
      - src/world/executor.py
    acceptance_criteria:
      - Permission check cost tracked
      - Requester always pays for permission checks
      - Cost attribution documented

  # =============================================================================
  # CONFIGURATION GAPS
  # =============================================================================

  - id: GAP-RES-022
    component: resources
    dimension: configuration
    title: "Missing per-agent initial rate allocation config"
    current_state: |
      Per-tick compute quota configurable.
      All agents get same allocation.
      No initial allocation specification per agent.
    target_state: |
      Per-agent initial allocation in config:
      resources:
        llm_rate:
          provider_limit: 100000
          initial_allocation:
            agent_a: 50000
            agent_b: 30000
      New agents start with 0, must acquire via trade.
    delta: |
      Add per-agent allocation config:
      - initial_allocation map per resource
      - Validation that sum equals provider limit
      - Default 0 for new agents
    dependencies:
      - GAP-RES-013
    complexity: M
    risk: low
    files_affected:
      - config/schema.yaml
      - config/config.yaml
      - src/config.py
    acceptance_criteria:
      - Per-agent allocation configurable
      - Sum validation against provider limit
      - New agents default to 0 allocation

  - id: GAP-RES-023
    component: resources
    dimension: configuration
    title: "Missing worker pool configuration"
    current_state: |
      No worker pool exists.
      No configuration for pool size.
    target_state: |
      Worker pool config:
      resources:
        worker_pool:
          max_workers: null  # null = os.cpu_count()
      Pool size configurable or auto-detected.
    delta: |
      Add worker pool configuration with sensible defaults.
    dependencies:
      - GAP-RES-008
    complexity: S
    risk: low
    files_affected:
      - config/schema.yaml
      - config/config.yaml
    acceptance_criteria:
      - worker_pool.max_workers configurable
      - null defaults to os.cpu_count()
      - Explicit value overrides auto-detection

  - id: GAP-RES-024
    component: resources
    dimension: configuration
    title: "Missing external API configuration structure"
    current_state: |
      LLM config exists for API provider.
      No structure for other external APIs.
    target_state: |
      Unified external API config:
      resources:
        external_apis:
          llm:
            provider: gemini
            tokens_per_minute: 100000
            budget_usd: 10.00
          web_search:
            queries_per_minute: 60
            budget_usd: 5.00
          github:
            requests_per_minute: 100
    delta: |
      Add external_apis config section with per-API settings.
    dependencies: []
    complexity: M
    risk: low
    files_affected:
      - config/schema.yaml
      - config/config.yaml
    acceptance_criteria:
      - external_apis section in config
      - Per-API rate and budget settings
      - Common providers pre-configured

  - id: GAP-RES-025
    component: resources
    dimension: configuration
    title: "Missing allocation_mode config for resources"
    current_state: |
      No concept of allocation mode.
      All agents share resources equally by default.
    target_state: |
      allocation_mode: strict
      Unused capacity wasted (not borrowable by others).
      Strong incentive to trade unused allocation.
    delta: |
      Add allocation_mode config option.
    dependencies:
      - GAP-RES-001
    complexity: S
    risk: low
    files_affected:
      - config/schema.yaml
    acceptance_criteria:
      - allocation_mode configurable
      - "strict" mode enforces no sharing
      - Documentation explains modes

  # =============================================================================
  # CONSTRAINTS GAPS
  # =============================================================================

  - id: GAP-RES-026
    component: resources
    dimension: constraints
    title: "Missing Docker integration for real resource limits"
    current_state: |
      Resource limits are abstract numbers.
      No mapping to container constraints.
    target_state: |
      Docker IS the constraint:
      docker run --memory=4g --cpus=2 agent-ecology
      Stock resources map to container limits.
    delta: |
      Document and implement Docker resource mapping:
      - Container limits as source of truth
      - Config values derived from container settings
      - Integration guidance
    dependencies: []
    complexity: M
    risk: low
    files_affected:
      - config/schema.yaml
      - docs/architecture/current/resources.md
    acceptance_criteria:
      - Docker resource limits documented
      - Config can reference container limits
      - Deployment guide includes Docker settings

  - id: GAP-RES-027
    component: resources
    dimension: constraints
    title: "Missing sum validation for rate allocations"
    current_state: |
      No validation that allocations sum to provider limit.
    target_state: |
      Sum of allocations must equal provider limit.
      Unallocated rate is wasted.
      Validation fails if sum != provider_limit.
    delta: |
      Add validation for rate allocation totals.
    dependencies:
      - GAP-RES-022
    complexity: S
    risk: low
    files_affected:
      - src/config.py
    acceptance_criteria:
      - Config validation checks allocation sums
      - Clear error message on mismatch
      - Allows intentional under-allocation with flag

  - id: GAP-RES-028
    component: resources
    dimension: constraints
    title: "No hardcoded agent limits - flow rate as throttle"
    current_state: |
      No explicit agent limits documented.
      System doesn't use flow rate as throttle.
    target_state: |
      No "max N agents per tick" limit.
      Flow rate naturally limits throughput.
      Agents in debt skip actions (fewer concurrent).
    delta: |
      Ensure no artificial agent limits exist.
      Document flow rate as natural throttle mechanism.
    dependencies:
      - GAP-RES-001
    complexity: S
    risk: low
    files_affected:
      - docs/architecture/current/resources.md
    acceptance_criteria:
      - No hardcoded agent limits in code
      - Flow rate documented as throttle mechanism
      - System scales with rate configuration

  # =============================================================================
  # BREAKING CHANGES (from target Migration Notes)
  # =============================================================================

  - id: GAP-RES-029
    component: resources
    dimension: behaviors
    title: "Breaking change: advance_tick() no longer resets renewable resources"
    current_state: |
      advance_tick() resets flow resources to quota.
    target_state: |
      advance_tick() does NOT reset renewable resources.
      Only rate tracker manages renewable resource availability.
    delta: |
      Remove resource reset from advance_tick() for renewable types.
    dependencies:
      - GAP-RES-001
      - GAP-RES-018
    complexity: S
    risk: high
    files_affected:
      - src/world/world.py
    acceptance_criteria:
      - advance_tick() only handles non-renewable resources
      - Tests updated for new behavior
      - Migration documented

  - id: GAP-RES-030
    component: resources
    dimension: interfaces
    title: "Breaking change: ledger.set_resource() replaced with rate tracker"
    current_state: |
      ledger.set_resource() used to set resource values.
    target_state: |
      set_resource() removed for renewable resources.
      Rate tracker manages renewable resource state.
    delta: |
      Remove set_resource() for renewables, migrate to rate tracker.
    dependencies:
      - GAP-RES-001
      - GAP-RES-015
    complexity: M
    risk: high
    files_affected:
      - src/world/ledger.py
      - src/world/world.py
    acceptance_criteria:
      - set_resource() deprecated/removed for renewables
      - Rate tracker is sole manager of renewable state
      - All callers migrated
